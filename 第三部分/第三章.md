

# 现代javascript教程

## 第3部分：其他文章

### 第三章、网络请求

#### 3.1Fetch

当需要加载新信息时，JavaScript 可以向服务器发送网络请求。

例如，我们可以：

- 提交订单，
- 加载用户信息，
- 接受来自服务器的最新更新，
- ……等等。

……所有这些都不需重新加载页面！

它有个通用术语称为“AJAX”（**A**synchronous **J**avascript **A**nd **X**ml 的首字母缩写）。我们不必使用 XML：这个术语很早就产生了，这个词一直在那里。

有很多办法向服务器发送请求并获取信息。

`fetch()` 方法是一种现代通用方法，那么我们就从它开始吧。它已经发展了几年了并在不断改进，现在它已经得到很多浏览器的支持了。

基本语法：

```javascript
let promise = fetch(url, [options])
```

- **`url`** —— 要访问的 URL。
- **`options`** —— 可选参数：method，headers 等。

浏览器立即发送请求，并返回一个 `promise`。

获取响应通常需要经过两个阶段。

**第一阶段，当服务器发送了响应头，由`fetch`返回的`promise`将使用内置Response类的对象进行解析。**

因此，我们可以通过检测 HTTP 状态来确定请求是否成功，或者当响应体还没有返回时，通过检查响应头来确定状态。

如果 `fetch` 无法建立一个 HTTP 请求，例如网络问题，亦或是请求的网址不存在，那么 promise 就返回 reject。HTTP 错误，即使是 404 或者 500，也被视为正常的过程。

我们可以在 response 属性里看到它们：

- **`ok`** —— 布尔值，如果 HTTP 状态码在 200-299 之间，返回 `true`。
- **`status`** —— HTTP 状态码。

例如：

```javascript
let response = await fetch(url);

if (response.ok) { // 如果 HTTP 状态码在 200-299 之间
  // 获取响应体（如下所示）
  let json = await response.json();
} else {
  alert("HTTP-Error: " + response.status);
}
```

**第二阶段，为了获取响应体，我们需要调用其他方法。**

`Response` 提供了多种基于 promise 的方法来获取不同格式的响应正文：

- **`response.json()`** —— 将 response 解析为 JSON 对象，
- **`response.text()`** —— 以文本形式返回 response，
- **`response.formData()`** —— 以 `FormData` 对象（form/multipart 编码（encoding），我们将在[下一章](https://zh.javascript.info/formdata)中了解到更多）的形式返回 response。
- **`response.blob()`** —— 以 [Blob](https://zh.javascript.info/blob) （具有类型的二进制数据）形式返回 response，
- **`response.arrayBuffer()`** —— 以 [ArrayBuffer](https://zh.javascript.info/arraybuffer-binary-arrays) （纯二进制数据）形式返回 response，
- 另外，`response.body` 是 [ReadableStream](https://streams.spec.whatwg.org/#rs-class) 对象，它允许逐块读取正文，我们稍后会用一个例子解释它。

例如，我们来获取 GitHub 上最新 commits 的 JSON 对象：

```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let commits = await response.json(); // 获取 response body 并解析为 JSON

alert(commits[0].author.login);
```

也可以使用纯 promise 语法，不使用 `await`：

```javascript
fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));
```

要获取文本，可以使用 `await response.text()` 代替 `.json()`：

```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let text = await response.text(); // 以 text 形式读取响应体

alert(text.slice(0, 80) + '...');
```

我们以使用`fetch` 并显示一张图像为例来了解一下读取二进制文件的情况（参见 [Blob](https://zh.javascript.info/blob) 章节以了解更多关于 blob 的操作）：

```javascript
let response = await fetch('/article/fetch/logo-fetch.svg');

let blob = await response.blob(); // 以 Blob 对象下载

// 创建 <img> 元素
let img = document.createElement('img');
img.style = 'position:fixed;top:10px;left:10px;width:100px';
document.body.append(img);

// 显示图片
img.src = URL.createObjectURL(blob);

setTimeout(() => { // 3 秒后隐藏
  img.remove();
  URL.revokeObjectURL(img.src);
}, 3000);
```

------

**重要：**

我们只能选择其中一种解析响应体的方式。

如果我们以 `response.text()` 方法来获取 response，那么如果我们再用 `response.json()` 方法的话，那么这个方法是不会生效的，因为正文内容已经被处理过了。

```javascript
let text = await response.text(); // 响应体被处理
let parsed = await response.json(); // 错误（已被处理）
```

##### [Response headers](https://javascript.info/fetch#response-headers)

`response.headers` 中有一个类似于 Map 的 headers 对象。

我们可以获取单个的 headers 或者迭代它们：

```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// 获取其中一个 header
alert(response.headers.get('Content-Type')); // application/json; charset=utf-8

// 迭代所有 headers
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`);
}
```

##### [Request headers](https://javascript.info/fetch#request-headers)

我们可以使用 `headers` 选项来设置 header，就像这样：

```javascript
let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'abcdef'
  }
});
```

但是有一些 headers 我们无法去设置它（详细列表参见 [forbidden HTTP headers](https://fetch.spec.whatwg.org/#forbidden-header-name)）：

- `Accept-Charset`, `Accept-Encoding`
- `Access-Control-Request-Headers`
- `Access-Control-Request-Method`
- `Connection`
- `Content-Length`
- `Cookie`, `Cookie2`
- `Date`
- `DNT`
- `Expect`
- `Host`
- `Keep-Alive`
- `Origin`
- `Referer`
- `TE`
- `Trailer`
- `Transfer-Encoding`
- `Upgrade`
- `Via`
- `Proxy-*`
- `Sec-*`

这些 headers 保证了 HTTP 的正确性和安全性，所以它们仅由浏览器控制。

##### [POST 请求](https://zh.javascript.info/fetch#post-qing-qiu)

创建一个 `POST` 请求，或者其他方法（HTTP method）的请求，我们需要使用 `fetch` 相关选项：

- **`method`** —— HTTP 方法（HTTP-method），例如 `POST`，

- `body`—— 其中之一：

  - 字符串（例如 JSON），
  - `FormData` 对象，以 `form/multipart` 形式发送数据，
  - `Blob`/`BufferSource` 发送二进制数据，
  - [URLSearchParams](https://zh.javascript.info/url)，以 `x-www-form-urlencoded` 编码形式发送数据，很少使用。

例如，下面这段代码以 JSON 形式发送 `user` 对象：

```javascript
let user = {
  name: 'John',
  surname: 'Smith'
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});

let result = await response.json();
alert(result.message);
```

请注意，如果 body 是字符串，`Content-Type` 默认会设置为 `text/plain;charset=UTF-8`。所以我们使用 `headers`值为 `application/json` 来代替默认值，这是 JSON 编码的数据的正确格式。

##### [发送图片](https://zh.javascript.info/fetch#fa-song-tu-pian)

我们同样可以用 `Blob` 或者 `BufferSource` 来发送二进制数据。

例如，这里有个我们可以通过移动鼠标来绘制图像的 `<canvas>` 元素。“submit” 按钮可以用来向服务器发送绘制的图片：

```html
<body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Submit" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
      let response = await fetch('/article/fetch/post/image', {
        method: 'POST',
        body: blob
      });
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
```

同样，我们也不需要手动设置 `Content-Type`，因为 `Blob` 对象有一个内置的类型（这里是 `image/png`，通过 `toBlob`自动生成的）。

`submit()` 函数可以不使用 `async/await`，改写后如下：

```javascript
function submit() {
  canvasElem.toBlob(function(blob) {
    fetch('/article/fetch/post/image', {
      method: 'POST',
      body: blob
    })
      .then(response => response.json())
      .then(result => alert(JSON.stringify(result, null, 2)))
  }, 'image/png');
}
```

##### [总结](https://zh.javascript.info/fetch#zong-jie)  

典型的 fetch 请求包含两个 `await`：

```javascript
let response = await fetch(url, options); // 解析 response headers
let result = await response.json(); // 以 JSON 形式读取数据
```

或者以 promise 形式：

```javascript
fetch(url, options)
  .then(response => response.json())
  .then(result => /* 处理结果 */)
```

响应属性：

- `response.status` —— response 的 HTTP 状态码，
- `response.ok` —— HTTP 状态码在 200-299 之间返回 `true`。
- `response.headers` —— 类似于 Map 的 HTTP headers 对象。

获取响应体的方法：

- **`response.json()`** —— 以 JSON 对象形式解析 response，
- **`response.text()`** —— 以 text 形式返回 response，
- **`response.formData()`** —— 以 `FormData` 对象（form/multipart 编码，参见下一章）形式返回 response，
- **`response.blob()`** —— 以 [Blob](https://zh.javascript.info/blob)（具有类型的二进制数据）形式返回 response，
- **`response.arrayBuffer()`** —— 以 [ArrayBuffer](https://zh.javascript.info/arraybuffer-binary-arrays)（纯二进制数据）返回 response。

到目前为止我们了解的 fetch 选项包括：

- `method` —— HTTP 方法（HTTP-method）,
- `headers` —— 具有请求头的 headers 对象（不是所有请求头都是被允许的）
- `body` —— 以 `string`，`FormData`，`BufferSource`，`Blob` 或者 `UrlSearchParams` 对象发送数据。

在下一章中，我们将会看到更多关于 `fetch` 的选项以及使用场景。

##### 任务

###### [从 GitHub fetch 用户信息](https://zh.javascript.info/fetch#cong-githubfetch-yong-hu-xin-xi)

记录下这道题目，回顾下`promise`。（[一个不错的讲解](https://segmentfault.com/a/1190000020034361)）

创建能从一组 GitHub 用户数组获取一组数据的异步函数 `getUsers(names)`，从 GitHub 获取用户信息并返回一组 GitHub 用户信息的数组。

给定 `USERNAME` 的用户信息的 GitHub 网址是：`https://api.github.com/users/USERNAME`。

总要细节：

1. 每一个用户都应该有一个 `fetch` 请求，并且请求是独立的不用彼此等待。因此数据能尽快获取到。
2. 如果任意一个请求失败了，或者没有这个用户，函数应该返回 `null` 到最终结果数组中。

**Answer**

要获取一个用户，我们需要：

1. `fetch('https://api.github.com/users/USERNAME')`.
2. 如果响应状态码是 `200` 就调用 `.json()` 来读取 JS 对象。

如果 `fetch` 失败，或者响应状态码不是 200，我们只要返回 `null` 到最终结果数组中就行了。

下面是参考代码：

```javascript
async function getUsers(names) {
  let jobs = [];

  for(let name of names) {
    let job = fetch(`https://api.github.com/users/${name}`).then(
      successResponse => {
        if (successResponse.status != 200) {
          return null;
        } else {
          return successResponse.json();
        }
      },
      failResponse => {
        return null;
      }
    );
    jobs.push(job);
  }

  let results = await Promise.all(jobs);

  return results;
}
```

请注意：`.then` 紧跟在 `fetch` 后面，因此当我们有了响应数据，它就不会等待其他的 fetch 请求而直接开始读取 `.json()`。

**如果我们使用 `await Promise.all(names.map(name => fetch(...)))`，且在其结果上调用 `.json()`方法，那么它将会等到所有 fetch 都获取到响应数据才开始解析。通过直接添加 `.json()` 到每个 `fetch`，我们就能确保每个 fetch 都能读取 JSON 数据而不用等待其他 fetch 请求。**

这个例子表明，即使我们主要使用 `async/await`，低级（low-level）的 `Promise` API 仍然很有用。

#### 3.2FormData

这一章是关于发送 HTML 表单的：发送文件或者附加字段等。[FormData](https://xhr.spec.whatwg.org/#interface-formdata) 对象可以解决这个问题。

构造函数是：

```javascript
let formData = new FormData([form]);
```

如果提供了 HTML `form` 元素，它会自动获取 `form` 元素字段。你可能已经猜到了，`FormData` 是用于保存和发送表单数据的对象。

`FormData` 特殊之处在于它的网络方法（network methods），比如 `fetch` 接受一个 `FormData` 对象作为 body。它会被编码并并且发送出去，该请求带有 `Content-Type: form/multipart`。因此，从服务器角度来看，它就像是一个普通的表单提交。

##### [发送一个简单 form](https://zh.javascript.info/formdata#fa-song-yi-ge-jian-dan-form)

我们首先来发送一个简单的 form。

正如你所见，它几乎就是一行命令：

```html
<form id="formElem">
  <input type="text" name="name" value="John">
  <input type="text" name="surname" value="Smith">
  <input type="submit">
</form>

<script>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('/article/formdata/post/user', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };
</script>
```

##### [FormData 方法](https://zh.javascript.info/formdata#formdata-fang-fa)

- `formData.append(name, value)` – 添加给定的 `name` 和 `value` 的值到 form 表单，
- `formData.append(name, blob, fileName)` – 当 form 为 `<input type="file">` 时，添加字段，第三个参数 `fileName` 设置文件名（不是 form 字段名）作为用户文件系统（filesystem）中的文件名，
- `formData.delete(name)` – 移除给定 `name` 的字段，
- `formData.get(name)` – 获取给定 `name` 的字段值，
- `formData.has(name)` – 如果存在给定 `name` 的字段，则返回 `true`，否则返回 `false`

从技术上来讲，form 允许有多个相同 `name` 的字段，因此，多次调用 `append` 将会添加多个相同名称的字段。

同样也有一个与 `append` 语法类似的 `set` 方法。不同之处在于 `.set` 移除所有给定 `name` 的字段，然后附加一个新字段。因此它确保了具有 `name` 名称的字段的唯一性。

- `formData.set(name, value)`,
- `formData.set(name, blob, fileName)`.

同样我们也可以使用 `for..of` 循环迭代所有 formData 字段：

```javascript
let formData = new FormData();
formData.append('key1', 'value1');
formData.append('key2', 'value2');

// 列出 key/value 对
for(let [name, value] of formData) {
  alert(`${name} = ${value}`); // key1=value1，然后是 key2=value2
}
```

##### [发送文件的表单](https://zh.javascript.info/formdata#fa-song-wen-jian-de-biao-dan)

Form 默认以 `Content-Type: form/multipart` 来发送数据，这个编码允许发送文件。因此 `<input type="file">`字段也能被发送，类似于普通的表单提交。

这里是发送文件表单的例子：

```html
<form id="formElem">
  <input type="text" name="firstName" value="John">
  Picture: <input type="file" name="picture" accept="image/*">
  <input type="submit">
</form>

<script>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('/article/formdata/post/user-avatar', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };
</script>
```

##### [发送 Blob 数据的表单](https://zh.javascript.info/formdata#fa-song-blob-shu-ju-de-biao-dan)

正如我们在 [Fetch](https://zh.javascript.info/fetch) 章节所见，发送一个动态生成的 `Blob`，比如图像，是很简单的。我们可以将它作为 `fetch` 参数的 `body`。

但在实践中，通常发送图像更加简便的方法不是单独发送，而是作为 form 的一部分发送图像，以及其他字段，例如“name”和其他元数据。

另外，服务器通常更适合接受 multipart-encoded form，而不是原始二进制数据。

下面这个例子使用 `FormData` 从 `<canvas>` 发送一个图片，以及其他一些字段：

```html
<body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Submit" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let imageBlob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));

      let formData = new FormData();
      formData.append("firstName", "John");
      formData.append("image", imageBlob, "image.png");

      let response = await fetch('/article/formdata/post/image-form', {
        method: 'POST',
        body: formData
      });
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
```

请注意 `Blob` 是如何添加的：

```javascript
formData.append("image", imageBlob, "image.png");
```

这与在表单中有 `<input type="file" name="image">` 类似，用户从它们的文件系统中提交名为 `image.png`（第三个参数）的文件。

##### [总结](https://zh.javascript.info/formdata#zong-jie)

[FormData](https://xhr.spec.whatwg.org/#interface-formdata) 对象是用来捕获 HTML form 并使用 `fetch` 或者其他网络方法提交捕获的数据。

我们可以从 HTML form 中创建一个 `new FormData(form)`，也可以创建一个空的对象，然后使用下面方法追加字段：

- `formData.append(name, value)`
- `formData.append(name, blob, fileName)`
- `formData.set(name, value)`
- `formData.set(name, blob, fileName)`

两个特点：

1. `set` 方法移除移除具有相同名称的字段而 `append` 不会。
2. 发送文件需要三个参数，最后一个参数是文件名，一般是通过 `<input type="file">` 元素从用户文件系统中获取的。

其他方法是：

- `formData.delete(name)`
- `formData.get(name)`
- `formData.has(name)`

这就是它的全貌！

#### 3.3Fetch：下载过程

`fetch` 方法允许去追踪 *download* 过程。

请注意：到目前为止，对于 `fetch` 方法的 *upload* 过程，还没有方法去追踪它。基于这个目的，请使用 [XMLHttpRequest](https://zh.javascript.info/xmlhttprequest)，我们将会在后面讲到它。

要追踪下载过程，可以使用 `response.body` 属性。它是一个“可读流（readable stream）”——当他们下载的时候提供一个个响应体块（chunk）的特殊对象。

与 `response.text()`，`response.json()` 和其他方法不同，`response.body` 完全控制了读取过程，我们可以随时计算下载了多少。

下面是从 `response.body` 读取 response 的代码草图：

```javascript
// 代替 response.json() 以及其他方法
const reader = response.body.getReader();

// 无限循环执行直到 body 下载完成
while(true) {
  // 当最后一块下载完成时，done 值为 true
  // value 是存放块字节码的 Uint8Array
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Received ${value.length} bytes`)
}
```

`await reader.read()` 的结果是一个具有两个属性的对象：

- **`done`** —— 当块全部下载完毕时，其值为 true。
- **`value`** —— 一个存放字节码的类型数组：`Uint8Array`。

我们在循环中等待更多的块（chunk），直到 `done` 是 `true`。

要打印 progress 的话，我们只需向 counter 添加每个 `value` 的长度。

这是完整的获取响应并打印进度的代码，更多解释如下：

```javascript
// Step 1：启动 fetch 并赋值给 reader
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// Step 2：获取总长度（总块数）
const contentLength = +response.headers.get('Content-Length');

// Step 3：读取数据
let receivedLength = 0; // 当前长度
let chunks = []; // 存放接收到的二进制块的数组（包括 body）
while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  chunks.push(value);
  receivedLength += value.length;

  console.log(`Received ${receivedLength} of ${contentLength}`)
}

// Step 4：将块合并成单个 Uint8Array
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
  chunksAll.set(chunk, position); // (4.2)
  position += chunk.length;
}

// Step 5：解码成字符串
let result = new TextDecoder("utf-8").decode(chunksAll);

// 我们完成啦！
let commits = JSON.parse(result);
alert(commits[0].author.login);
```

------

**注意**

并不是所有`Response`的`header`中都会返回`Content-Length`，笔者亲自测试这个示例中就无法得到该参数（但是不是这个例子的代码有问题哦），原因的话比较多的，在此不过多赘述，可自行去查找了解。

另外在使用`fetch`的时候，建议在`headers`中加入`Connection: 'keep-alive'`，原因什么的肯定是自己找最快乐了！

------

让我们一步步阐释这个过程：

1. 我们像往常一样执行 `fetch`，但不是调用 `response.json()`，而是获取一个流读取器（stream reader）`response.body.getReader()`。

   请注意，我们不能同时使用这些方法来读取相同的响应。要么使用流读取器，要么使用 reponse 方法来获得响应结果。

2. 在阅读之前，我们可以从 `Content-Length` 头中找出完整的响应长度。

   跨域请求可能不存在这个（请参见 [Fetch：跨源请求](https://zh.javascript.info/fetch-crossorigin)），并且从技术上讲，服务器可以不设置它。但是通常情况下响应头中都会存在。

3. 调用 `await reader.read()` 直到它已经完成。

   我们将响应的数据 `chunks` 收集到数组中。这很重要，因为当响应结束后，我们就不能再使用 `response.json()` 或者 其他方法（你可以试试，它将会出错）去“重新读取”它。

4. 最后，我们有了一个 `Uint8Array` 字节块数组。我们需要将这些块合并成一个响应结果。但不幸的是，没有一个方法来合并它们，所以这里需要一些代码来实现：

   1. 我们创建 `new Uint8Array(receivedLength)` —— 一个具有所有数据块合并后的长度的同类型数组。
   2. 然后使用 `.set(chunk, position)` 方法从数组中一个个复制这些 `chunk`。

5. 我们的结果现在储存在 `chunksAll` 中。它是字节组成的数组而不是字符串。

   要创建字符串，我们需要解析这些字节。可以使用内置的 [TextDecoder](https://zh.javascript.info/text-decoder) 对象来操作。然后我们就可以对其使用 `JSON.parse`。

   如果我们需要二进制内容而不是 JSON 呢？这甚是简单。只需要调用所有块中的 blob 来代替步骤 4 和步骤 5。

   ```javascript
   let blob = new Blob(chunks);
   ```

最终我们将得到结果（以 string 或者 blob 呈现，什么方便就用什么）以及进程中的跟踪进度。

再一次提醒，这个进度仅仅是对于 *download* 来说的而不是 *upload* 过程（`fetch` 目前还没办法做到这点）。

#### 3.4**Fetch：中止（Abort）**

中止 `fetch` 有一点点棘手。请记住，`fetch` 返回 promise。但是 JavaScript 并没有 “中止” promise 的概念。所以我们要如何取消 fetch 呢？

有一个特殊的内置对象是基于此目的的：`AbortController`。

使用起来很简单：

- Step 1：创建一个控制器（controller）：

  ```javascript
  let controller = new AbortController();
  ```

  控制器是个极其简单的对象。它具有一个 `abort()` 方法和一个 `signal` 属性。当 `abort()` 被调用时，`abort` 事件就会在 `controller.signal` 上触发。

  控制器是个极其简单的对象。它具有一个 `abort()` 方法和一个 `signal` 属性。当 `abort()` 被调用时，`abort` 事件就会在 `controller.signal` 上触发。

  就像这样：

  ```javascript
  let controller = new AbortController();
  let signal = controller.signal;
  
  // triggers when controller.abort() is called
  signal.addEventListener('abort', () => alert("abort!"));
  
  controller.abort(); // 中止！
  
  alert(signal.aborted); // true（在中止之后）
  ```

- Step 2：将 `signal` 属性传递给 `fetch` 选项：

  ```javascript
  let controller = new AbortController();
  fetch(url, {
    signal: controller.signal
  });
  ```

  现在 `fetch` 监听 signal。

- Step 3：调用 `controller.abort()` 来中止：

  ```javascript
  controller.abort();
  ```

  我们完成啦：`fetch` 从 `signal` 那里获取事件并中止请求。

当一个 fetch 被中止，它的 promise rejects 一个名为 `AbortError` 的错误，所以我们应该处理它：

```javascript
// 1 秒后中止
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);

try {
  let response = await fetch('/article/fetch-abort/demo/hang', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') { // handle abort()
    alert("Aborted!");
  } else {
    throw err;
  }
}
```

**`AbortController` 是可扩展的，它允许同时取消多个 fetch。**

例如，这里我们并行 fetch 多个 `urls`，然后控制器将它们全部中止：

```javascript
let urls = [...]; // 将要并行 fetch 的 urls 列表

let controller = new AbortController();

let fetchJobs = urls.map(url => fetch(url, {
  signal: controller.signal
}));

let results = await Promise.all(fetchJobs);

// 从其他地方：
// controller.abort() 中止所有 fetches
```

如果我们有自己的不同于 `fetch` 的任务，我们可以使用一个 `AbortController` 去中止它们以及 fetches。

```javascript
let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) => {
  ...
  controller.signal.addEventListener('abort', reject); // 将reject方法写入abort的监听中
});

let fetchJobs = urls.map(url => fetch(url, {
  signal: controller.signal
}));

let results = await Promise.all([...fetchJobs, ourJob]);

// 从其他地方：
// controller.abort() 中止所有 fetches 和 ourJob
```

#### 3.5Fetch：跨源请求

如果我们对任意网站发起 `fetch` 请求，那可能会出现失败情况。

这里的核心概念是 *origin* —— 域（domain）/端口（port）/协议（protocol）的组合。

跨源请求 —— 那些发送到其他域（即使是子域）、协议或者端口 —— 要求服务端提供特殊的头。这个政策被称为“CORS”：跨域资源共享（Cross-Origin Resource Sharing）。

例如，我们尝试获取 `http://example.com`：

```javascript
try {
  await fetch('http://example.com');
} catch(err) {
  alert(err); // 无法获取
}
```

不出意外，获取失败。

##### [为什么？跨源请求简明史](https://zh.javascript.info/fetch-crossorigin#wei-shi-mo-kua-yuan-qing-qiu-jian-ming-shi)

因为跨源限制可以保护互联网免受恶意黑客攻击。

说真的，在这说点儿题外话，讲讲它的历史。

**多年来，来自某个网站的脚本无法访问另一个网站的内容。**

这个简单有力的规则是互联网安全的基础。例如，来自 `hacker.com` 页面的脚本无法访问 `gmail.com` 上的用户邮箱。基于这样的规则，人们感到很安全。

在那时候，JavaScript 只是一种装饰网页的玩具语言而已，它并没有任何特殊的执行网络请求的方法。

但是网络开发人员需要更多的控制权。人们发明了各种各样的技巧去突破它的限制。

###### [使用 forms](https://zh.javascript.info/fetch-crossorigin#shi-yong-forms)

其中一种和其他服务器通信的方法是提交一个 `<form>`。人们将它提交到 `<iframe>` ，目的只是为了仍然留在当前页面，像这样：

```html
<!-- form 目标 -->
<iframe name="iframe"></iframe>

<!-- form 可以使用 JavaScript 动态生成并提交 -->
<form target="iframe" method="POST" action="http://another.com/…">
  ...
</form>
```

因此，即使没有网络方法，它也可以向其他网站发起一个 GET/POST 请求。但是由于禁止从其他网页读取 `<iframe>` 的内容，因此就无法读取响应。

正如所见，forms 可以在任意位置发送数据，但是不能接受响应内容。确切地说，还是有一些技巧能够解决这个问题的（iframe 和页面中都需要添加特殊脚本），不过我们还是让这些老古董代码不要再出现了吧。

###### [使用 scripts](https://zh.javascript.info/fetch-crossorigin#shi-yong-scripts)

另一个技巧是使用 `<script src="http://another.com/…">` 标签。脚本元素可以有来自任何域的任何 `src` 值。但同样 —— 无法访问此类脚本的原始内容。

如果 `another.com` 试图公开这种访问的数据，则使用所谓的“JSONP（JSON with padding）”协议。

假设我们需要以这种方式从 `http://another.com` 站点获取数据：

1. 首先，我们提前声明一个全局函数来接收数据，例如 `gotWeather`。

   ```javascript
   // 1. 声明处理数据的函数
   function gotWeather({ temperature, humidity }) {
     alert(`temperature: ${temperature}, humidity: ${humidity}`);
   }
   ```

2. 然后我们创建属性为 `src="http://another.com/weather.json?callback=gotWeather"` 的 `<script>` 标签，请注意我们的函数名是作为它的 `callback` 参数。

   ```javascript
   let script = document.createElement('script');
   script.src = `http://another.com/weather.json?callback=gotWeather`;
   document.body.append(script);
   ```

3. 服务器动态生成一个名为 `gotWeather(...)` 的脚本，脚本内包含我们想要接收的数据。

   ```javascript
   // 期望从服务器获取到的结果类似于此：
   gotWeather({
     temperature: 25,
     humidity: 78
   });
   ```

4. 当远端脚本加载并执行的时候，`gotWeather` 函数被调用，并且因为它是我们的函数，我们就有需要的数据了。

这是可行的，并且不违反安全规定，因为双方网站都接受这种传递数据的方式。既然双方网站都同意这种行为，那么它肯定不是网络攻击了。现在仍然有提供这种访问的服务，因为即使是非常旧的浏览器也依然可行。

不久之后，出现了具体的网络处理方法，例如 `XMLHttpRequest`。

起初，跨源请求是被禁止的。但是由于长时间的讨论，跨源请求最终被允许：除非服务器明确允许，否则不会添加任何功能。

##### [简单请求（Simple requests）](https://zh.javascript.info/fetch-crossorigin#jian-dan-qing-qiu-simplerequests)

有两种跨域（cross-domain）请求：

1. 简单请求。
2. 除简单请求以外的其他请求。

顾名思义，简单请求很简单，所以我们先从它开始。

一个 [简单请求](http://www.w3.org/TR/cors/#terminology) 是指满足下列条件的请求：

1. [简单请求方法](http://www.w3.org/TR/cors/#simple-method)：GET, POST 或 HEAD

2. 简单请求头

    

   — 仅允许自定义下列请求头：

   - `Accept`，
   - `Accept-Language`，
   - `Content-Language`，
   - `Content-Type` 的值为 `application/x-www-form-urlencoded`， `multipart/form-data` 或 `text/plain`.

任何其他的请求都被视为“非简单请求（non-simple）”。例如，具有 `PUT` 方法或者 `API-Key` HTTP 头的请求就不是简单请求了。

任何其他的请求都被视为“非简单请求（non-simple）”。例如，具有 `PUT` 方法或者 `API-Key` HTTP 头的请求就不是简单请求了。

**本质区别在于，可以使用 `<form>` 或者 `<script>` 进行“简单请求”，而无需任何特殊方法。**

所以，即使是非常旧的服务器也能很好地接收简单请求。

与此相反，使用非标准头，或者说比如 `DELETE` 这样的方法就不能以这种方式创建。在很长一段时间内，JavaScript 都不能建立这样的请求。所以，旧的服务器可能会认为此类请求来自具有特权的来源，“因为网页无法发送它们”。

当我们试图建立非简单请求时，浏览器发送一个特殊的“预检（preflight）”请求到服务器 —— 是否接受这类跨源请求吗？

并且，除非服务器明确通过头确认，否则非简单请求不会被发送。

现在，我们将详细介绍它们。所有这些都有一个目的 —— 那就是确保只有来自服务器的明确许可才能访问新的跨源功能。

##### [用于简单请求的 CORS](https://zh.javascript.info/fetch-crossorigin#yong-yu-jian-dan-qing-qiu-de-cors)

如果一个请求是跨源的，浏览器始终会向其添加 `Origin` 头。

例如，如果我们从 `https://javascript.info/page` 请求 `https://anywhere.com/request`，请求头就类似于：

```none
GET /request
Host: anywhere.com
Origin: https://javascript.info
...
```

正如你所见，`Origin` 包含完整的源（domain/protocol/port），没有路径。

服务器可以检查 `Origin`，如果同意接受这样的请求，就会在响应中添加一个特殊的头 `Access-Control-Allow-Origin`。该头包含了允许的源（在我们示例中是 `https://javascript.info`），或者星号 `*`。然后响应成功，否则报错。

浏览器在这里扮演受信任的中间人角色：

1. 它确保通过跨域请求发送正确的 `Origin`。
2. 如果在响应中检查出正确的 `Access-Control-Allow-Origin`，如果是，则 JavaScript 能正常访问（目标资源），否则被禁止并报错。

![image-20191209204341941](第三章.assets/image-20191209204341941.png)

这是一个得到服务器许可的响应示例：

```none
200 OK
Content-Type:text/html; charset=UTF-8
Access-Control-Allow-Origin: https://javascript.info
```

##### [响应头（Response headers）](https://zh.javascript.info/fetch-crossorigin#xiang-ying-tou-responseheaders)

对于跨源请求，默认情况下 JavaScript 只能访问“简单响应头”：

- `Cache-Control`
- `Content-Language`
- `Content-Type`
- `Expires`
- `Last-Modified`
- `Pragma`

任何其他响应头都是禁止的。

------

**请注意：没有 `Content-Length`**

请注意：列表中没有 `Content-Length` 头！

这个头包含了完整响应长度。所以，如果我们想要追踪下载内容的进度百分比，则需要额外的权限才能访问该头（参见下文）。

------

要允许 JavaScript 访问任何其他响应头，服务器必须在响应头中列出 `Access-Control-Expose-Headers`。

例如：

```none
200 OK
Content-Type:text/html; charset=UTF-8
Content-Length: 12345
API-Key: 2c9de507f2c54aa1
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Expose-Headers: Content-Length,API-Key
```

有了 `Access-Control-Expose-Headers` 响应头，脚本就有权限访问响应的 `Content-Length` 和 `API-Key` 头。

##### [“非简单” requests](https://zh.javascript.info/fetch-crossorigin#fei-jian-dan-requests)

我们可以使用任何 HTTP 方法：不仅仅是 `GET/POST`，也可以是 `PATCH`，`DELETE` 及其他。

之前，没有人能够设想网页能做出这样的请求。所以可能存在有些网络服务视非标准方法为一个信号：“这不是浏览器”。它们可以在检查访问权限时将其考虑在内。

因此，为了避免误解，任何“非标准”请求 —— 在过去无法完成，浏览器不会立即发出此类请求。在它发送请求前，会先发送“预检请求”来获取权限。

预检请求使用 `OPTIONS` 方法，并且没有 body。

- `Access-Control-Request-Method` 头带有请求方法。
- `Access-Control-Request-Headers` 头提供以逗号分隔的非简单 HTTP 头列表。

如果服务器同意请求，那么它响应状态码应该为 200，没有 body。

- 响应头 `Access-Control-Allow-Methods` 必须具有允许的方法。
- 响应头 `Access-Control-Allow-Headers` 必须具有允许的头列表。
- 另外，响应头 `Access-Control-Max-Age` 可以指定缓存此权限的秒数。因此，浏览器不必为满足给定权限的后续请求发送预检。

![image-20191209204708190](第三章.assets/image-20191209204708190.png)

让我们用一个例子来一步步展示它是怎么工作的，对于跨域的 `PATCH` 请求（这个方法通常被用来上传数据）：

```javascript
let response = await fetch('https://site.com/service.json', {
  method: 'PATCH',
  headers: {
    'Content-Type': 'application/json'
    'API-Key': 'secret'
  }
});
```

这里有三个理由解释为什么它不是一个简单请求（其实一个就够了）：

- 方法：`PATCH`
- `Content-Type` 不是这三个中的一个：`application/x-www-form-urlencoded`，`multipart/form-data`，`text/plain`。
- “非简单（Non-simple）” `API-Key` 头。

###### [Step 1 预检请求（preflight request）](https://zh.javascript.info/fetch-crossorigin#step-1-yu-jian-qing-qiu-preflightrequest)

在我们发送请求之前，浏览器自身会发送类似这样的预检请求：

```none
OPTIONS /service.json
Host: site.com
Origin: https://javascript.info
Access-Control-Request-Method: PATCH
Access-Control-Request-Headers: Content-Type,API-Key
```

- 方法：`OPTIONS`。
- 路径 —— 与主请求完全相同：`/service.json`。
- 特殊跨源头：
  - `Origin` —— 来源。
  - `Access-Control-Request-Method` —— 请求方法。
  - `Access-Control-Request-Headers` —— 以逗号分隔的“非简单”头列表。

###### [Step 2 预检响应（preflight response）](https://zh.javascript.info/fetch-crossorigin#step-2-yu-jian-xiang-ying-preflightresponse)

服务应响应状态 200 和响应头：

- `Access-Control-Allow-Methods: PATCH`
- `Access-Control-Allow-Headers: Content-Type,API-Key`.

这将允许后续通信，否则会触发错误。

如果服务器将来需要其他的方法和头，那么添加到列表中来提前允许它们是很有意义的：

```none
200 OK
Access-Control-Allow-Methods: PUT,PATCH,DELETE
Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
Access-Control-Max-Age: 86400
```

现在，浏览器可以在允许的方法列表里找到 `PATCH`，并且这两个头也都在列表中，因此它发送主请求。

此外，预检请求会按指定时间缓存，由 `Access-Control-Max-Age` 头指定（86400 秒，一天），因此，后续请求将不会再发送预检请求。假设它们符合配额，它们将直接发送。

###### [Step 3 实际请求（actual request）](https://zh.javascript.info/fetch-crossorigin#step-3-shi-ji-qing-qiu-actualrequest)

当预检请求成功后，浏览器将会发送实际请求。这里的流程和简单请求相同。

实际请求有 `Origin` 头（因为它是跨源的）：

```none
PATCH /service.json
Host: site.com
Content-Type: application/json
API-Key: secret
Origin: https://javascript.info
```

###### [Step 4 实际响应（actual response）](https://zh.javascript.info/fetch-crossorigin#step-4-shi-ji-xiang-ying-actualresponse)

服务器记得要在 response 中添加 Access-Control-Allow-Origin，因为一次成功预检并不能解除潜在的风险：

```none
Access-Control-Allow-Origin: https://javascript.info
```

现在所有事情都是正确的。JavaScript 可以读取完整的响应了。

##### [凭据（Credentials）](https://zh.javascript.info/fetch-crossorigin#ping-ju-credentials)

默认情况下，跨源请求不会带来任何凭据（cookies 或者 HTTP 认证（HTTP authentication））。

这对于 HTTP 请求来说并不常见。通常，对 `http://site.com` 的请求附带来自该域的所有 cookies。但是对于 JavaScript 方法建立的跨源请求是个例外。

例如，`fetch('http://another.com')` 不会发送任何 cookies，甚至那些属于 `another.com` 域的 cookies。

为什么？

这是因为具有凭据的请求比匿名请求具有的权限更大。如果被允许，它授予 JavaScript 代表用户行为和访问敏感信息的全部权限。

服务器真的这么信任来自 `Origin` 的页面吗？是的，它必须明确地允许带有附加请求头凭据的请求。

要发送凭据，我们需要添加选项 `credentials: "include"`，就像这样：

```javascript
fetch('http://another.com', {
  credentials: "include"
});
```

现在，`fetch` 会发送源自 `another.com` 的 cookies，但不会向该站点发出请求。

如果服务器想要接受带有凭据的请求，则除了 `Access-Control-Allow-Origin` 外，它还需要向响应头中添加 `Access-Control-Allow-Credentials: true`。

例如：

```none
200 OK
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Credentials: true
```

请注意：对于具有凭据的请求，禁止使用 `Access-Control-Allow-Origin` 为 `*`。它必须有一个确切的源，像上面一样。这是一项额外的安全措施，以确保服务器真正知道它信任谁。

##### [总结](https://zh.javascript.info/fetch-crossorigin#zong-jie)

网络方法将跨源请求分为两类：“简单”请求和除“简单”请求之外其他的请求。

[简单请求](http://www.w3.org/TR/cors/#terminology) 必须满足下列条件：

- 方法：GET，POST 或 HEAD。
- 头 —— 我们仅能设置：
  - `Accept`
  - `Accept-Language`
  - `Content-Language`
  - `Content-Type` 的值为 `application/x-www-form-urlencoded`，`multipart/form-data` 或 `text/plain`。

简单请求和其他请求的本质区别在于，自古以来使用 `<form>` 或 `<script>` 标签就可以发送简单请求，而长期来浏览器都不能使用非简单请求。

所以，实际区别在于简单请求会使用 `Origin` 头并立即发送，而对于其他请求，浏览器会发出初步的预检请求，请求获得许可。

**对于简单请求：**

- → 浏览器发送带有源的 `Origin` 头。
- ← 对于没有凭据的请求（默认不发送），服务器应该设置：
  - `Access-Control-Allow-Origin` 为 `*` 或与 `Origin` 值相同
- ← 对于具有凭据的请求，服务器应该设置：
  - `Access-Control-Allow-Origin` 值与 `Origin` 相同
  - `Access-Control-Allow-Credentials` 为 `true`

此外，如果 JavaScript 期望访问非简单响应头：

- `Cache-Control`
- `Content-Language`
- `Content-Type`
- `Expires`
- `Last-Modified`
- `Pragma`

…服务器应列出 `Access-Control-Expose-Headers` 头中允许的那些。

**对于非简单请求，会在请求之前发出初步“预检”请求：

- → 浏览器发送 `OPTIONS` 请求到相同的 url，同时具有下列头：
  - `Access-Control-Request-Method` 请求方法。
  - `Access-Control-Request-Headers` 非简单请求头列表
- ← 服务器应该响应状态码为 200 和响应头：
  - `Access-Control-Allow-Methods` 具有一系列允许方法的列表，
  - `Access-Control-Allow-Headers` 具有一系列允许头的列表，
  - `Access-Control-Max-Age` 用指定数字来设置缓存权限的时间。
- 最后发出实际请求，应用先前的“简单”方案。


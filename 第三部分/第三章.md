# 现代javascript教程

## 第3部分：其他文章

### 第三章、网络请求

#### 3.1Fetch

当需要加载新信息时，JavaScript 可以向服务器发送网络请求。

例如，我们可以：

- 提交订单，
- 加载用户信息，
- 接受来自服务器的最新更新，
- ……等等。

……所有这些都不需重新加载页面！

它有个通用术语称为“AJAX”（**A**synchronous **J**avascript **A**nd **X**ml 的首字母缩写）。我们不必使用 XML：这个术语很早就产生了，这个词一直在那里。

有很多办法向服务器发送请求并获取信息。

`fetch()` 方法是一种现代通用方法，那么我们就从它开始吧。它已经发展了几年了并在不断改进，现在它已经得到很多浏览器的支持了。

基本语法：

```javascript
let promise = fetch(url, [options])
```

- **`url`** —— 要访问的 URL。
- **`options`** —— 可选参数：method，headers 等。

浏览器立即发送请求，并返回一个 `promise`。

获取响应通常需要经过两个阶段。

**第一阶段，当服务器发送了响应头，由`fetch`返回的`promise`将使用内置Response类的对象进行解析。**

因此，我们可以通过检测 HTTP 状态来确定请求是否成功，或者当响应体还没有返回时，通过检查响应头来确定状态。

如果 `fetch` 无法建立一个 HTTP 请求，例如网络问题，亦或是请求的网址不存在，那么 promise 就返回 reject。HTTP 错误，即使是 404 或者 500，也被视为正常的过程。

我们可以在 response 属性里看到它们：

- **`ok`** —— 布尔值，如果 HTTP 状态码在 200-299 之间，返回 `true`。
- **`status`** —— HTTP 状态码。

例如：

```javascript
let response = await fetch(url);

if (response.ok) { // 如果 HTTP 状态码在 200-299 之间
  // 获取响应体（如下所示）
  let json = await response.json();
} else {
  alert("HTTP-Error: " + response.status);
}
```

**第二阶段，为了获取响应体，我们需要调用其他方法。**

`Response` 提供了多种基于 promise 的方法来获取不同格式的响应正文：

- **`response.json()`** —— 将 response 解析为 JSON 对象，
- **`response.text()`** —— 以文本形式返回 response，
- **`response.formData()`** —— 以 `FormData` 对象（form/multipart 编码（encoding），我们将在[下一章](https://zh.javascript.info/formdata)中了解到更多）的形式返回 response。
- **`response.blob()`** —— 以 [Blob](https://zh.javascript.info/blob) （具有类型的二进制数据）形式返回 response，
- **`response.arrayBuffer()`** —— 以 [ArrayBuffer](https://zh.javascript.info/arraybuffer-binary-arrays) （纯二进制数据）形式返回 response，
- 另外，`response.body` 是 [ReadableStream](https://streams.spec.whatwg.org/#rs-class) 对象，它允许逐块读取正文，我们稍后会用一个例子解释它。

例如，我们来获取 GitHub 上最新 commits 的 JSON 对象：

```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let commits = await response.json(); // 获取 response body 并解析为 JSON

alert(commits[0].author.login);
```

也可以使用纯 promise 语法，不使用 `await`：

```javascript
fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));
```

要获取文本，可以使用 `await response.text()` 代替 `.json()`：

```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let text = await response.text(); // 以 text 形式读取响应体

alert(text.slice(0, 80) + '...');
```

我们以使用`fetch` 并显示一张图像为例来了解一下读取二进制文件的情况（参见 [Blob](https://zh.javascript.info/blob) 章节以了解更多关于 blob 的操作）：

```javascript
let response = await fetch('/article/fetch/logo-fetch.svg');

let blob = await response.blob(); // 以 Blob 对象下载

// 创建 <img> 元素
let img = document.createElement('img');
img.style = 'position:fixed;top:10px;left:10px;width:100px';
document.body.append(img);

// 显示图片
img.src = URL.createObjectURL(blob);

setTimeout(() => { // 3 秒后隐藏
  img.remove();
  URL.revokeObjectURL(img.src);
}, 3000);
```

------

**重要：**

我们只能选择其中一种解析响应体的方式。

如果我们以 `response.text()` 方法来获取 response，那么如果我们再用 `response.json()` 方法的话，那么这个方法是不会生效的，因为正文内容已经被处理过了。

```javascript
let text = await response.text(); // 响应体被处理
let parsed = await response.json(); // 错误（已被处理）
```

##### [Response headers](https://javascript.info/fetch#response-headers)

`response.headers` 中有一个类似于 Map 的 headers 对象。

我们可以获取单个的 headers 或者迭代它们：

```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// 获取其中一个 header
alert(response.headers.get('Content-Type')); // application/json; charset=utf-8

// 迭代所有 headers
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`);
}
```

##### [Request headers](https://javascript.info/fetch#request-headers)

我们可以使用 `headers` 选项来设置 header，就像这样：

```javascript
let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'abcdef'
  }
});
```

但是有一些 headers 我们无法去设置它（详细列表参见 [forbidden HTTP headers](https://fetch.spec.whatwg.org/#forbidden-header-name)）：

- `Accept-Charset`, `Accept-Encoding`
- `Access-Control-Request-Headers`
- `Access-Control-Request-Method`
- `Connection`
- `Content-Length`
- `Cookie`, `Cookie2`
- `Date`
- `DNT`
- `Expect`
- `Host`
- `Keep-Alive`
- `Origin`
- `Referer`
- `TE`
- `Trailer`
- `Transfer-Encoding`
- `Upgrade`
- `Via`
- `Proxy-*`
- `Sec-*`

这些 headers 保证了 HTTP 的正确性和安全性，所以它们仅由浏览器控制。

##### [POST 请求](https://zh.javascript.info/fetch#post-qing-qiu)

创建一个 `POST` 请求，或者其他方法（HTTP method）的请求，我们需要使用 `fetch` 相关选项：

- **`method`** —— HTTP 方法（HTTP-method），例如 `POST`，

- `body`—— 其中之一：

  - 字符串（例如 JSON），
  - `FormData` 对象，以 `form/multipart` 形式发送数据，
  - `Blob`/`BufferSource` 发送二进制数据，
  - [URLSearchParams](https://zh.javascript.info/url)，以 `x-www-form-urlencoded` 编码形式发送数据，很少使用。

例如，下面这段代码以 JSON 形式发送 `user` 对象：

```javascript
let user = {
  name: 'John',
  surname: 'Smith'
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});

let result = await response.json();
alert(result.message);
```

请注意，如果 body 是字符串，`Content-Type` 默认会设置为 `text/plain;charset=UTF-8`。所以我们使用 `headers`值为 `application/json` 来代替默认值，这是 JSON 编码的数据的正确格式。

##### [发送图片](https://zh.javascript.info/fetch#fa-song-tu-pian)

我们同样可以用 `Blob` 或者 `BufferSource` 来发送二进制数据。

例如，这里有个我们可以通过移动鼠标来绘制图像的 `<canvas>` 元素。“submit” 按钮可以用来向服务器发送绘制的图片：

```html
<body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Submit" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
      let response = await fetch('/article/fetch/post/image', {
        method: 'POST',
        body: blob
      });
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
```

同样，我们也不需要手动设置 `Content-Type`，因为 `Blob` 对象有一个内置的类型（这里是 `image/png`，通过 `toBlob`自动生成的）。

`submit()` 函数可以不使用 `async/await`，改写后如下：

```javascript
function submit() {
  canvasElem.toBlob(function(blob) {
    fetch('/article/fetch/post/image', {
      method: 'POST',
      body: blob
    })
      .then(response => response.json())
      .then(result => alert(JSON.stringify(result, null, 2)))
  }, 'image/png');
}
```

##### [总结](https://zh.javascript.info/fetch#zong-jie)  

典型的 fetch 请求包含两个 `await`：

```javascript
let response = await fetch(url, options); // 解析 response headers
let result = await response.json(); // 以 JSON 形式读取数据
```

或者以 promise 形式：

```javascript
fetch(url, options)
  .then(response => response.json())
  .then(result => /* 处理结果 */)
```

响应属性：

- `response.status` —— response 的 HTTP 状态码，
- `response.ok` —— HTTP 状态码在 200-299 之间返回 `true`。
- `response.headers` —— 类似于 Map 的 HTTP headers 对象。

获取响应体的方法：

- **`response.json()`** —— 以 JSON 对象形式解析 response，
- **`response.text()`** —— 以 text 形式返回 response，
- **`response.formData()`** —— 以 `FormData` 对象（form/multipart 编码，参见下一章）形式返回 response，
- **`response.blob()`** —— 以 [Blob](https://zh.javascript.info/blob)（具有类型的二进制数据）形式返回 response，
- **`response.arrayBuffer()`** —— 以 [ArrayBuffer](https://zh.javascript.info/arraybuffer-binary-arrays)（纯二进制数据）返回 response。

到目前为止我们了解的 fetch 选项包括：

- `method` —— HTTP 方法（HTTP-method）,
- `headers` —— 具有请求头的 headers 对象（不是所有请求头都是被允许的）
- `body` —— 以 `string`，`FormData`，`BufferSource`，`Blob` 或者 `UrlSearchParams` 对象发送数据。

在下一章中，我们将会看到更多关于 `fetch` 的选项以及使用场景。

##### 任务

###### [从 GitHub fetch 用户信息](https://zh.javascript.info/fetch#cong-githubfetch-yong-hu-xin-xi)

记录下这道题目，回顾下`promise`。（[一个不错的讲解](https://segmentfault.com/a/1190000020034361)）

创建能从一组 GitHub 用户数组获取一组数据的异步函数 `getUsers(names)`，从 GitHub 获取用户信息并返回一组 GitHub 用户信息的数组。

给定 `USERNAME` 的用户信息的 GitHub 网址是：`https://api.github.com/users/USERNAME`。

总要细节：

1. 每一个用户都应该有一个 `fetch` 请求，并且请求是独立的不用彼此等待。因此数据能尽快获取到。
2. 如果任意一个请求失败了，或者没有这个用户，函数应该返回 `null` 到最终结果数组中。

**Answer**

要获取一个用户，我们需要：

1. `fetch('https://api.github.com/users/USERNAME')`.
2. 如果响应状态码是 `200` 就调用 `.json()` 来读取 JS 对象。

如果 `fetch` 失败，或者响应状态码不是 200，我们只要返回 `null` 到最终结果数组中就行了。

下面是参考代码：

```javascript
async function getUsers(names) {
  let jobs = [];

  for(let name of names) {
    let job = fetch(`https://api.github.com/users/${name}`).then(
      successResponse => {
        if (successResponse.status != 200) {
          return null;
        } else {
          return successResponse.json();
        }
      },
      failResponse => {
        return null;
      }
    );
    jobs.push(job);
  }

  let results = await Promise.all(jobs);

  return results;
}
```

请注意：`.then` 紧跟在 `fetch` 后面，因此当我们有了响应数据，它就不会等待其他的 fetch 请求而直接开始读取 `.json()`。

**如果我们使用 `await Promise.all(names.map(name => fetch(...)))`，且在其结果上调用 `.json()`方法，那么它将会等到所有 fetch 都获取到响应数据才开始解析。通过直接添加 `.json()` 到每个 `fetch`，我们就能确保每个 fetch 都能读取 JSON 数据而不用等待其他 fetch 请求。**

这个例子表明，即使我们主要使用 `async/await`，低级（low-level）的 `Promise` API 仍然很有用。

#### 3.2FormData

这一章是关于发送 HTML 表单的：发送文件或者附加字段等。[FormData](https://xhr.spec.whatwg.org/#interface-formdata) 对象可以解决这个问题。

构造函数是：

```javascript
let formData = new FormData([form]);
```

如果提供了 HTML `form` 元素，它会自动获取 `form` 元素字段。你可能已经猜到了，`FormData` 是用于保存和发送表单数据的对象。

`FormData` 特殊之处在于它的网络方法（network methods），比如 `fetch` 接受一个 `FormData` 对象作为 body。它会被编码并并且发送出去，该请求带有 `Content-Type: form/multipart`。因此，从服务器角度来看，它就像是一个普通的表单提交。

##### [发送一个简单 form](https://zh.javascript.info/formdata#fa-song-yi-ge-jian-dan-form)

我们首先来发送一个简单的 form。

正如你所见，它几乎就是一行命令：

```html
<form id="formElem">
  <input type="text" name="name" value="John">
  <input type="text" name="surname" value="Smith">
  <input type="submit">
</form>

<script>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('/article/formdata/post/user', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };
</script>
```

##### [FormData 方法](https://zh.javascript.info/formdata#formdata-fang-fa)

- `formData.append(name, value)` – 添加给定的 `name` 和 `value` 的值到 form 表单，
- `formData.append(name, blob, fileName)` – 当 form 为 `<input type="file">` 时，添加字段，第三个参数 `fileName` 设置文件名（不是 form 字段名）作为用户文件系统（filesystem）中的文件名，
- `formData.delete(name)` – 移除给定 `name` 的字段，
- `formData.get(name)` – 获取给定 `name` 的字段值，
- `formData.has(name)` – 如果存在给定 `name` 的字段，则返回 `true`，否则返回 `false`

从技术上来讲，form 允许有多个相同 `name` 的字段，因此，多次调用 `append` 将会添加多个相同名称的字段。

同样也有一个与 `append` 语法类似的 `set` 方法。不同之处在于 `.set` 移除所有给定 `name` 的字段，然后附加一个新字段。因此它确保了具有 `name` 名称的字段的唯一性。

- `formData.set(name, value)`,
- `formData.set(name, blob, fileName)`.

同样我们也可以使用 `for..of` 循环迭代所有 formData 字段：

```javascript
let formData = new FormData();
formData.append('key1', 'value1');
formData.append('key2', 'value2');

// 列出 key/value 对
for(let [name, value] of formData) {
  alert(`${name} = ${value}`); // key1=value1，然后是 key2=value2
}
```

##### [发送文件的表单](https://zh.javascript.info/formdata#fa-song-wen-jian-de-biao-dan)

Form 默认以 `Content-Type: form/multipart` 来发送数据，这个编码允许发送文件。因此 `<input type="file">`字段也能被发送，类似于普通的表单提交。

这里是发送文件表单的例子：

```html
<form id="formElem">
  <input type="text" name="firstName" value="John">
  Picture: <input type="file" name="picture" accept="image/*">
  <input type="submit">
</form>

<script>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('/article/formdata/post/user-avatar', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };
</script>
```

##### [发送 Blob 数据的表单](https://zh.javascript.info/formdata#fa-song-blob-shu-ju-de-biao-dan)

正如我们在 [Fetch](https://zh.javascript.info/fetch) 章节所见，发送一个动态生成的 `Blob`，比如图像，是很简单的。我们可以将它作为 `fetch` 参数的 `body`。

但在实践中，通常发送图像更加简便的方法不是单独发送，而是作为 form 的一部分发送图像，以及其他字段，例如“name”和其他元数据。

另外，服务器通常更适合接受 multipart-encoded form，而不是原始二进制数据。

下面这个例子使用 `FormData` 从 `<canvas>` 发送一个图片，以及其他一些字段：

```html
<body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Submit" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let imageBlob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));

      let formData = new FormData();
      formData.append("firstName", "John");
      formData.append("image", imageBlob, "image.png");

      let response = await fetch('/article/formdata/post/image-form', {
        method: 'POST',
        body: formData
      });
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
```

请注意 `Blob` 是如何添加的：

```javascript
formData.append("image", imageBlob, "image.png");
```

这与在表单中有 `<input type="file" name="image">` 类似，用户从它们的文件系统中提交名为 `image.png`（第三个参数）的文件。

##### [总结](https://zh.javascript.info/formdata#zong-jie)

[FormData](https://xhr.spec.whatwg.org/#interface-formdata) 对象是用来捕获 HTML form 并使用 `fetch` 或者其他网络方法提交捕获的数据。

我们可以从 HTML form 中创建一个 `new FormData(form)`，也可以创建一个空的对象，然后使用下面方法追加字段：

- `formData.append(name, value)`
- `formData.append(name, blob, fileName)`
- `formData.set(name, value)`
- `formData.set(name, blob, fileName)`

两个特点：

1. `set` 方法移除移除具有相同名称的字段而 `append` 不会。
2. 发送文件需要三个参数，最后一个参数是文件名，一般是通过 `<input type="file">` 元素从用户文件系统中获取的。

其他方法是：

- `formData.delete(name)`
- `formData.get(name)`
- `formData.has(name)`

这就是它的全貌！

#### 3.3Fetch：下载过程

`fetch` 方法允许去追踪 *download* 过程。

请注意：到目前为止，对于 `fetch` 方法的 *upload* 过程，还没有方法去追踪它。基于这个目的，请使用 [XMLHttpRequest](https://zh.javascript.info/xmlhttprequest)，我们将会在后面讲到它。

要追踪下载过程，可以使用 `response.body` 属性。它是一个“可读流（readable stream）”——当他们下载的时候提供一个个响应体块（chunk）的特殊对象。

与 `response.text()`，`response.json()` 和其他方法不同，`response.body` 完全控制了读取过程，我们可以随时计算下载了多少。

下面是从 `response.body` 读取 response 的代码草图：

```javascript
// 代替 response.json() 以及其他方法
const reader = response.body.getReader();

// 无限循环执行直到 body 下载完成
while(true) {
  // 当最后一块下载完成时，done 值为 true
  // value 是存放块字节码的 Uint8Array
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Received ${value.length} bytes`)
}
```

`await reader.read()` 的结果是一个具有两个属性的对象：

- **`done`** —— 当块全部下载完毕时，其值为 true。
- **`value`** —— 一个存放字节码的类型数组：`Uint8Array`。

我们在循环中等待更多的块（chunk），直到 `done` 是 `true`。

要打印 progress 的话，我们只需向 counter 添加每个 `value` 的长度。

这是完整的获取响应并打印进度的代码，更多解释如下：

```javascript
// Step 1：启动 fetch 并赋值给 reader
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// Step 2：获取总长度（总块数）
const contentLength = +response.headers.get('Content-Length');

// Step 3：读取数据
let receivedLength = 0; // 当前长度
let chunks = []; // 存放接收到的二进制块的数组（包括 body）
while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  chunks.push(value);
  receivedLength += value.length;

  console.log(`Received ${receivedLength} of ${contentLength}`)
}

// Step 4：将块合并成单个 Uint8Array
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
  chunksAll.set(chunk, position); // (4.2)
  position += chunk.length;
}

// Step 5：解码成字符串
let result = new TextDecoder("utf-8").decode(chunksAll);

// 我们完成啦！
let commits = JSON.parse(result);
alert(commits[0].author.login);
```

------

**注意**

并不是所有`Response`的`header`中都会返回`Content-Length`，笔者亲自测试这个示例中就无法得到该参数（但是不是这个例子的代码有问题哦），原因的话比较多的，在此不过多赘述，可自行去查找了解。

另外在使用`fetch`的时候，建议在`headers`中加入`Connection: 'keep-alive'`，原因什么的肯定是自己找最快乐了！

------

让我们一步步阐释这个过程：

1. 我们像往常一样执行 `fetch`，但不是调用 `response.json()`，而是获取一个流读取器（stream reader）`response.body.getReader()`。

   请注意，我们不能同时使用这些方法来读取相同的响应。要么使用流读取器，要么使用 reponse 方法来获得响应结果。

2. 在阅读之前，我们可以从 `Content-Length` 头中找出完整的响应长度。

   跨域请求可能不存在这个（请参见 [Fetch：跨源请求](https://zh.javascript.info/fetch-crossorigin)），并且从技术上讲，服务器可以不设置它。但是通常情况下响应头中都会存在。

3. 调用 `await reader.read()` 直到它已经完成。

   我们将响应的数据 `chunks` 收集到数组中。这很重要，因为当响应结束后，我们就不能再使用 `response.json()` 或者 其他方法（你可以试试，它将会出错）去“重新读取”它。

4. 最后，我们有了一个 `Uint8Array` 字节块数组。我们需要将这些块合并成一个响应结果。但不幸的是，没有一个方法来合并它们，所以这里需要一些代码来实现：

   1. 我们创建 `new Uint8Array(receivedLength)` —— 一个具有所有数据块合并后的长度的同类型数组。
   2. 然后使用 `.set(chunk, position)` 方法从数组中一个个复制这些 `chunk`。

5. 我们的结果现在储存在 `chunksAll` 中。它是字节组成的数组而不是字符串。

   要创建字符串，我们需要解析这些字节。可以使用内置的 [TextDecoder](https://zh.javascript.info/text-decoder) 对象来操作。然后我们就可以对其使用 `JSON.parse`。

   如果我们需要二进制内容而不是 JSON 呢？这甚是简单。只需要调用所有块中的 blob 来代替步骤 4 和步骤 5。

   ```javascript
   let blob = new Blob(chunks);
   ```

最终我们将得到结果（以 string 或者 blob 呈现，什么方便就用什么）以及进程中的跟踪进度。

再一次提醒，这个进度仅仅是对于 *download* 来说的而不是 *upload* 过程（`fetch` 目前还没办法做到这点）。

#### 3.4**Fetch：中止（Abort）**

中止 `fetch` 有一点点棘手。请记住，`fetch` 返回 promise。但是 JavaScript 并没有 “中止” promise 的概念。所以我们要如何取消 fetch 呢？

有一个特殊的内置对象是基于此目的的：`AbortController`。

使用起来很简单：

- Step 1：创建一个控制器（controller）：

  ```javascript
  let controller = new AbortController();
  ```

  控制器是个极其简单的对象。它具有一个 `abort()` 方法和一个 `signal` 属性。当 `abort()` 被调用时，`abort` 事件就会在 `controller.signal` 上触发。

  控制器是个极其简单的对象。它具有一个 `abort()` 方法和一个 `signal` 属性。当 `abort()` 被调用时，`abort` 事件就会在 `controller.signal` 上触发。

  就像这样：

  ```javascript
  let controller = new AbortController();
  let signal = controller.signal;
  
  // triggers when controller.abort() is called
  signal.addEventListener('abort', () => alert("abort!"));
  
  controller.abort(); // 中止！
  
  alert(signal.aborted); // true（在中止之后）
  ```

- Step 2：将 `signal` 属性传递给 `fetch` 选项：

  ```javascript
  let controller = new AbortController();
  fetch(url, {
    signal: controller.signal
  });
  ```

  现在 `fetch` 监听 signal。

- Step 3：调用 `controller.abort()` 来中止：

  ```javascript
  controller.abort();
  ```

  我们完成啦：`fetch` 从 `signal` 那里获取事件并中止请求。

当一个 fetch 被中止，它的 promise rejects 一个名为 `AbortError` 的错误，所以我们应该处理它：

```javascript
// 1 秒后中止
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);

try {
  let response = await fetch('/article/fetch-abort/demo/hang', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') { // handle abort()
    alert("Aborted!");
  } else {
    throw err;
  }
}
```

**`AbortController` 是可扩展的，它允许同时取消多个 fetch。**

例如，这里我们并行 fetch 多个 `urls`，然后控制器将它们全部中止：

```javascript
let urls = [...]; // 将要并行 fetch 的 urls 列表

let controller = new AbortController();

let fetchJobs = urls.map(url => fetch(url, {
  signal: controller.signal
}));

let results = await Promise.all(fetchJobs);

// 从其他地方：
// controller.abort() 中止所有 fetches
```

如果我们有自己的不同于 `fetch` 的任务，我们可以使用一个 `AbortController` 去中止它们以及 fetches。

```javascript
let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) => {
  ...
  controller.signal.addEventListener('abort', reject); // 将reject方法写入abort的监听中
});

let fetchJobs = urls.map(url => fetch(url, {
  signal: controller.signal
}));

let results = await Promise.all([...fetchJobs, ourJob]);

// 从其他地方：
// controller.abort() 中止所有 fetches 和 ourJob
```

#### 3.5Fetch：跨源请求

如果我们对任意网站发起 `fetch` 请求，那可能会出现失败情况。

这里的核心概念是 *origin* —— 域（domain）/端口（port）/协议（protocol）的组合。

跨源请求 —— 那些发送到其他域（即使是子域）、协议或者端口 —— 要求服务端提供特殊的头。这个政策被称为“CORS”：跨域资源共享（Cross-Origin Resource Sharing）。

例如，我们尝试获取 `http://example.com`：

```javascript
try {
  await fetch('http://example.com');
} catch(err) {
  alert(err); // 无法获取
}
```

不出意外，获取失败。

##### [为什么？跨源请求简明史](https://zh.javascript.info/fetch-crossorigin#wei-shi-mo-kua-yuan-qing-qiu-jian-ming-shi)

因为跨源限制可以保护互联网免受恶意黑客攻击。

说真的，在这说点儿题外话，讲讲它的历史。

**多年来，来自某个网站的脚本无法访问另一个网站的内容。**

这个简单有力的规则是互联网安全的基础。例如，来自 `hacker.com` 页面的脚本无法访问 `gmail.com` 上的用户邮箱。基于这样的规则，人们感到很安全。

在那时候，JavaScript 只是一种装饰网页的玩具语言而已，它并没有任何特殊的执行网络请求的方法。

但是网络开发人员需要更多的控制权。人们发明了各种各样的技巧去突破它的限制。

###### [使用 forms](https://zh.javascript.info/fetch-crossorigin#shi-yong-forms)

其中一种和其他服务器通信的方法是提交一个 `<form>`。人们将它提交到 `<iframe>` ，目的只是为了仍然留在当前页面，像这样：

```html
<!-- form 目标 -->
<iframe name="iframe"></iframe>

<!-- form 可以使用 JavaScript 动态生成并提交 -->
<form target="iframe" method="POST" action="http://another.com/…">
  ...
</form>
```

因此，即使没有网络方法，它也可以向其他网站发起一个 GET/POST 请求。但是由于禁止从其他网页读取 `<iframe>` 的内容，因此就无法读取响应。

正如所见，forms 可以在任意位置发送数据，但是不能接受响应内容。确切地说，还是有一些技巧能够解决这个问题的（iframe 和页面中都需要添加特殊脚本），不过我们还是让这些老古董代码不要再出现了吧。

###### [使用 scripts](https://zh.javascript.info/fetch-crossorigin#shi-yong-scripts)

另一个技巧是使用 `<script src="http://another.com/…">` 标签。脚本元素可以有来自任何域的任何 `src` 值。但同样 —— 无法访问此类脚本的原始内容。

如果 `another.com` 试图公开这种访问的数据，则使用所谓的“JSONP（JSON with padding）”协议。

假设我们需要以这种方式从 `http://another.com` 站点获取数据：

1. 首先，我们提前声明一个全局函数来接收数据，例如 `gotWeather`。

   ```javascript
   // 1. 声明处理数据的函数
   function gotWeather({ temperature, humidity }) {
     alert(`temperature: ${temperature}, humidity: ${humidity}`);
   }
   ```

2. 然后我们创建属性为 `src="http://another.com/weather.json?callback=gotWeather"` 的 `<script>` 标签，请注意我们的函数名是作为它的 `callback` 参数。

   ```javascript
   let script = document.createElement('script');
   script.src = `http://another.com/weather.json?callback=gotWeather`;
   document.body.append(script);
   ```

3. 服务器动态生成一个名为 `gotWeather(...)` 的脚本，脚本内包含我们想要接收的数据。

   ```javascript
   // 期望从服务器获取到的结果类似于此：
   gotWeather({
     temperature: 25,
     humidity: 78
   });
   ```

4. 当远端脚本加载并执行的时候，`gotWeather` 函数被调用，并且因为它是我们的函数，我们就有需要的数据了。

这是可行的，并且不违反安全规定，因为双方网站都接受这种传递数据的方式。既然双方网站都同意这种行为，那么它肯定不是网络攻击了。现在仍然有提供这种访问的服务，因为即使是非常旧的浏览器也依然可行。

不久之后，出现了具体的网络处理方法，例如 `XMLHttpRequest`。

起初，跨源请求是被禁止的。但是由于长时间的讨论，跨源请求最终被允许：除非服务器明确允许，否则不会添加任何功能。

##### [简单请求（Simple requests）](https://zh.javascript.info/fetch-crossorigin#jian-dan-qing-qiu-simplerequests)

有两种跨域（cross-domain）请求：

1. 简单请求。
2. 除简单请求以外的其他请求。

顾名思义，简单请求很简单，所以我们先从它开始。

一个 [简单请求](http://www.w3.org/TR/cors/#terminology) 是指满足下列条件的请求：

1. [简单请求方法](http://www.w3.org/TR/cors/#simple-method)：GET, POST 或 HEAD

2. 简单请求头

    

   — 仅允许自定义下列请求头：

   - `Accept`，
   - `Accept-Language`，
   - `Content-Language`，
   - `Content-Type` 的值为 `application/x-www-form-urlencoded`， `multipart/form-data` 或 `text/plain`.

任何其他的请求都被视为“非简单请求（non-simple）”。例如，具有 `PUT` 方法或者 `API-Key` HTTP 头的请求就不是简单请求了。

任何其他的请求都被视为“非简单请求（non-simple）”。例如，具有 `PUT` 方法或者 `API-Key` HTTP 头的请求就不是简单请求了。

**本质区别在于，可以使用 `<form>` 或者 `<script>` 进行“简单请求”，而无需任何特殊方法。**

所以，即使是非常旧的服务器也能很好地接收简单请求。

与此相反，使用非标准头，或者说比如 `DELETE` 这样的方法就不能以这种方式创建。在很长一段时间内，JavaScript 都不能建立这样的请求。所以，旧的服务器可能会认为此类请求来自具有特权的来源，“因为网页无法发送它们”。

当我们试图建立非简单请求时，浏览器发送一个特殊的“预检（preflight）”请求到服务器 —— 是否接受这类跨源请求吗？

并且，除非服务器明确通过头确认，否则非简单请求不会被发送。

现在，我们将详细介绍它们。所有这些都有一个目的 —— 那就是确保只有来自服务器的明确许可才能访问新的跨源功能。

##### [用于简单请求的 CORS](https://zh.javascript.info/fetch-crossorigin#yong-yu-jian-dan-qing-qiu-de-cors)

如果一个请求是跨源的，浏览器始终会向其添加 `Origin` 头。

例如，如果我们从 `https://javascript.info/page` 请求 `https://anywhere.com/request`，请求头就类似于：

```none
GET /request
Host: anywhere.com
Origin: https://javascript.info
...
```

正如你所见，`Origin` 包含完整的源（domain/protocol/port），没有路径。

服务器可以检查 `Origin`，如果同意接受这样的请求，就会在响应中添加一个特殊的头 `Access-Control-Allow-Origin`。该头包含了允许的源（在我们示例中是 `https://javascript.info`），或者星号 `*`。然后响应成功，否则报错。

浏览器在这里扮演受信任的中间人角色：

1. 它确保通过跨域请求发送正确的 `Origin`。
2. 如果在响应中检查出正确的 `Access-Control-Allow-Origin`，如果是，则 JavaScript 能正常访问（目标资源），否则被禁止并报错。

![image-20191209204341941](第三章.assets/image-20191209204341941.png)

这是一个得到服务器许可的响应示例：

```none
200 OK
Content-Type:text/html; charset=UTF-8
Access-Control-Allow-Origin: https://javascript.info
```

##### [响应头（Response headers）](https://zh.javascript.info/fetch-crossorigin#xiang-ying-tou-responseheaders)

对于跨源请求，默认情况下 JavaScript 只能访问“简单响应头”：

- `Cache-Control`
- `Content-Language`
- `Content-Type`
- `Expires`
- `Last-Modified`
- `Pragma`

任何其他响应头都是禁止的。

------

**请注意：没有 `Content-Length`**

请注意：列表中没有 `Content-Length` 头！

这个头包含了完整响应长度。所以，如果我们想要追踪下载内容的进度百分比，则需要额外的权限才能访问该头（参见下文）。

------

要允许 JavaScript 访问任何其他响应头，服务器必须在响应头中列出 `Access-Control-Expose-Headers`。

例如：

```none
200 OK
Content-Type:text/html; charset=UTF-8
Content-Length: 12345
API-Key: 2c9de507f2c54aa1
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Expose-Headers: Content-Length,API-Key
```

有了 `Access-Control-Expose-Headers` 响应头，脚本就有权限访问响应的 `Content-Length` 和 `API-Key` 头。

##### [“非简单” requests](https://zh.javascript.info/fetch-crossorigin#fei-jian-dan-requests)

我们可以使用任何 HTTP 方法：不仅仅是 `GET/POST`，也可以是 `PATCH`，`DELETE` 及其他。

之前，没有人能够设想网页能做出这样的请求。所以可能存在有些网络服务视非标准方法为一个信号：“这不是浏览器”。它们可以在检查访问权限时将其考虑在内。

因此，为了避免误解，任何“非标准”请求 —— 在过去无法完成，浏览器不会立即发出此类请求。在它发送请求前，会先发送“预检请求”来获取权限。

预检请求使用 `OPTIONS` 方法，并且没有 body。

- `Access-Control-Request-Method` 头带有请求方法。
- `Access-Control-Request-Headers` 头提供以逗号分隔的非简单 HTTP 头列表。

如果服务器同意请求，那么它响应状态码应该为 200，没有 body。

- 响应头 `Access-Control-Allow-Methods` 必须具有允许的方法。
- 响应头 `Access-Control-Allow-Headers` 必须具有允许的头列表。
- 另外，响应头 `Access-Control-Max-Age` 可以指定缓存此权限的秒数。因此，浏览器不必为满足给定权限的后续请求发送预检。

![image-20191209204708190](第三章.assets/image-20191209204708190.png)

让我们用一个例子来一步步展示它是怎么工作的，对于跨域的 `PATCH` 请求（这个方法通常被用来上传数据）：

```javascript
let response = await fetch('https://site.com/service.json', {
  method: 'PATCH',
  headers: {
    'Content-Type': 'application/json'
    'API-Key': 'secret'
  }
});
```

这里有三个理由解释为什么它不是一个简单请求（其实一个就够了）：

- 方法：`PATCH`
- `Content-Type` 不是这三个中的一个：`application/x-www-form-urlencoded`，`multipart/form-data`，`text/plain`。
- “非简单（Non-simple）” `API-Key` 头。

###### [Step 1 预检请求（preflight request）](https://zh.javascript.info/fetch-crossorigin#step-1-yu-jian-qing-qiu-preflightrequest)

在我们发送请求之前，浏览器自身会发送类似这样的预检请求：

```none
OPTIONS /service.json
Host: site.com
Origin: https://javascript.info
Access-Control-Request-Method: PATCH
Access-Control-Request-Headers: Content-Type,API-Key
```

- 方法：`OPTIONS`。
- 路径 —— 与主请求完全相同：`/service.json`。
- 特殊跨源头：
  - `Origin` —— 来源。
  - `Access-Control-Request-Method` —— 请求方法。
  - `Access-Control-Request-Headers` —— 以逗号分隔的“非简单”头列表。

###### [Step 2 预检响应（preflight response）](https://zh.javascript.info/fetch-crossorigin#step-2-yu-jian-xiang-ying-preflightresponse)

服务应响应状态 200 和响应头：

- `Access-Control-Allow-Methods: PATCH`
- `Access-Control-Allow-Headers: Content-Type,API-Key`.

这将允许后续通信，否则会触发错误。

如果服务器将来需要其他的方法和头，那么添加到列表中来提前允许它们是很有意义的：

```none
200 OK
Access-Control-Allow-Methods: PUT,PATCH,DELETE
Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
Access-Control-Max-Age: 86400
```

现在，浏览器可以在允许的方法列表里找到 `PATCH`，并且这两个头也都在列表中，因此它发送主请求。

此外，预检请求会按指定时间缓存，由 `Access-Control-Max-Age` 头指定（86400 秒，一天），因此，后续请求将不会再发送预检请求。假设它们符合配额，它们将直接发送。

###### [Step 3 实际请求（actual request）](https://zh.javascript.info/fetch-crossorigin#step-3-shi-ji-qing-qiu-actualrequest)

当预检请求成功后，浏览器将会发送实际请求。这里的流程和简单请求相同。

实际请求有 `Origin` 头（因为它是跨源的）：

```none
PATCH /service.json
Host: site.com
Content-Type: application/json
API-Key: secret
Origin: https://javascript.info
```

###### [Step 4 实际响应（actual response）](https://zh.javascript.info/fetch-crossorigin#step-4-shi-ji-xiang-ying-actualresponse)

服务器记得要在 response 中添加 Access-Control-Allow-Origin，因为一次成功预检并不能解除潜在的风险：

```none
Access-Control-Allow-Origin: https://javascript.info
```

现在所有事情都是正确的。JavaScript 可以读取完整的响应了。

##### [凭据（Credentials）](https://zh.javascript.info/fetch-crossorigin#ping-ju-credentials)

默认情况下，跨源请求不会带来任何凭据（cookies 或者 HTTP 认证（HTTP authentication））。

这对于 HTTP 请求来说并不常见。通常，对 `http://site.com` 的请求附带来自该域的所有 cookies。但是对于 JavaScript 方法建立的跨源请求是个例外。

例如，`fetch('http://another.com')` 不会发送任何 cookies，甚至那些属于 `another.com` 域的 cookies。

为什么？

这是因为具有凭据的请求比匿名请求具有的权限更大。如果被允许，它授予 JavaScript 代表用户行为和访问敏感信息的全部权限。

服务器真的这么信任来自 `Origin` 的页面吗？是的，它必须明确地允许带有附加请求头凭据的请求。

要发送凭据，我们需要添加选项 `credentials: "include"`，就像这样：

```javascript
fetch('http://another.com', {
  credentials: "include"
});
```

现在，`fetch` 会发送源自 `another.com` 的 cookies，但不会向该站点发出请求。

如果服务器想要接受带有凭据的请求，则除了 `Access-Control-Allow-Origin` 外，它还需要向响应头中添加 `Access-Control-Allow-Credentials: true`。

例如：

```none
200 OK
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Credentials: true
```

请注意：对于具有凭据的请求，禁止使用 `Access-Control-Allow-Origin` 为 `*`。它必须有一个确切的源，像上面一样。这是一项额外的安全措施，以确保服务器真正知道它信任谁。

##### [总结](https://zh.javascript.info/fetch-crossorigin#zong-jie)

网络方法将跨源请求分为两类：“简单”请求和除“简单”请求之外其他的请求。

[简单请求](http://www.w3.org/TR/cors/#terminology) 必须满足下列条件：

- 方法：GET，POST 或 HEAD。
- 头 —— 我们仅能设置：
  - `Accept`
  - `Accept-Language`
  - `Content-Language`
  - `Content-Type` 的值为 `application/x-www-form-urlencoded`，`multipart/form-data` 或 `text/plain`。

简单请求和其他请求的本质区别在于，自古以来使用 `<form>` 或 `<script>` 标签就可以发送简单请求，而长期来浏览器都不能使用非简单请求。

所以，实际区别在于简单请求会使用 `Origin` 头并立即发送，而对于其他请求，浏览器会发出初步的预检请求，请求获得许可。

**对于简单请求：**

- → 浏览器发送带有源的 `Origin` 头。
- ← 对于没有凭据的请求（默认不发送），服务器应该设置：
  - `Access-Control-Allow-Origin` 为 `*` 或与 `Origin` 值相同
- ← 对于具有凭据的请求，服务器应该设置：
  - `Access-Control-Allow-Origin` 值与 `Origin` 相同
  - `Access-Control-Allow-Credentials` 为 `true`

此外，如果 JavaScript 期望访问非简单响应头：

- `Cache-Control`
- `Content-Language`
- `Content-Type`
- `Expires`
- `Last-Modified`
- `Pragma`

…服务器应列出 `Access-Control-Expose-Headers` 头中允许的那些。

**对于非简单请求，会在请求之前发出初步“预检”请求：

- → 浏览器发送 `OPTIONS` 请求到相同的 url，同时具有下列头：
  - `Access-Control-Request-Method` 请求方法。
  - `Access-Control-Request-Headers` 非简单请求头列表
- ← 服务器应该响应状态码为 200 和响应头：
  - `Access-Control-Allow-Methods` 具有一系列允许方法的列表，
  - `Access-Control-Allow-Headers` 具有一系列允许头的列表，
  - `Access-Control-Max-Age` 用指定数字来设置缓存权限的时间。
- 最后发出实际请求，应用先前的“简单”方案。

#### 3.6Fetch API

到目前为止，我们已经对 fetch 有一定的了解。

现在就让我们来看看 fetch 的其他 API，来了解它的全部能力吧。

------

**请注意：**

请注意：这些选项 (options) 大多很少使用。即使跳过这一章节，你也可以很好的使用 `fetch` 。

但是，知道 `fetch` 可以做什么也是很好的，所以如果你求知欲旺盛，你也可以来看看这些细节。

------

这个列表包含了 `fetch` 所有可能的选项和它们的默认值(可选值在注释中)：

```javascript
let promise = fetch(url, {
  method: "GET", // POST, PUT, DELETE, 等等.
  headers: {
    "Content-Type": "text/plain;charset=UTF-8" // 内容类型头的值通常会根据请求主体自动设置
  },
  body: undefined // string, FormData, Blob, BufferSource, 或者 URLSearchParams
  referrer: "about:client", // 无来源页 (no-referrer) 为 ''，或者是一个来自当前域名的 url
  referrerPolicy: "no-referrer-when-downgrade", // no-referrer, origin, same-origin...
  mode: "cors", // same-origin, no-cors
  credentials: "same-origin", // omit, include
  cache: "default", // no-store, reload, no-cache, force-cache, 或者 only-if-cached
  redirect: "follow", // manual, error
  integrity: "", // 一个 hash 值, 比如 "sha256-abcdef1234567890"
  keepalive: false, // true
  signal: undefined, // 终止请求的控制器
  window: window // null
});
```

一个令人印象深刻的列表，是吧?

我们已经在这个章节 文章 "fetch-basics" 未找到 详细介绍过 `method`, `headers` 和 `body` 了

`signal` 选项已经在 [Fetch：中止（Abort）](https://zh.javascript.info/fetch-abort) 章节讨论过了。

现在让我们探讨它其他的本领。

##### [referrer, referrerPolicy](https://zh.javascript.info/fetch-api#referrerreferrerpolicy)

这些选项决定了 `fetch` 如何设置 HTTP 的 `Referer` 头

通常来说，这个头部被自动设置并包含了发出请求的页面的 url。在大部分情况下，它只是个无关紧要的小角色，但有些时候出于安全考虑，对它的移除或缩短是由必要的。 .

**`referer` 选项允许设置任何在当前域名 (origin) 的 `Referer` 或者移除它。**

要发送无来源页，可以将 `referer` 设置为空字符串：

```javascript
fetch('/page', {
  referrer: "" // 没有 Referer 头部信息
});
```

设置在当前域名内的另一个 url：

```javascript
fetch('/page', {
  // 假设我们在 https://javascript.info
  // 我们可以设置任何 Referer 头部，但只能在当前网页源
  referrer: "https://javascript.info/anotherpage"
});
```

**`referrerPolicy` 选项为 `Referer` 设置通用规则。**

请求被分为 3 种类型：

1. 同源请求。
2. 跨域请求。
3. HTTPS 到 HTTP 的请求 (从安全协议到不安全协议)。

与 `referrer` 选项允许设置确切的 `Referer` 值不同， `referrerPolicy` 告诉浏览器针对各个请求类型的使用的通常的规则。

可能的值在 [Referrer Policy specification (来源协议规范)](https://w3c.github.io/webappsec-referrer-policy/) 中有介绍:

- **`"no-referrer-when-downgrade"`** – 默认值: 完整的 `Referer` 总被发送，除非我们从 HTTPS 发送请求到 HTTP (到较不安全协议)。
- **`"no-referrer"`** – 从不发送 `Referer`.
- **`"origin"`** – 只发送在 `Referer` 的域名，而不是整个页面 URL，比如，是发送 `http://site.com` 而不是 `http://site.com/path`。
- **`"origin-when-cross-origin"`** – 同源情况下，发送完整的 referer，但在跨域情况下，则只发送域名部分(同上)。
- **`"same-origin"`** – 同源情况下，发送完整的 referer，但在跨域情况下，则不发送 referer。
- **`"strict-origin"`** – 只发送域名，但在 HTTPS→HTTP 请求中则不发送 referer。
- **`"strict-origin-when-cross-origin"`** – 对于同源情况下则发送完整的 referer，对于跨域情况下则只发送域名，如果是 HTTPS→HTTP 请求，则什么都不发送。
- **`"unsafe-url"`** – 在 `Referer` 中总是发送完整的 url，即使是 HTTPS→HTTP 请求。

这是一个包含各种组合的表格：

| 值                                              | 同源       | 跨域       | HTTPS→HTTP |
| :---------------------------------------------- | :--------- | :--------- | :--------- |
| `"no-referrer"`                                 | -          | -          | -          |
| `"no-referrer-when-downgrade"` 或者 `""` (默认) | 完整的 url | 完整的 url | -          |
| `"origin"`                                      | 仅域名     | 仅域名     | 仅域名     |
| `"origin-when-cross-origin"`                    | 完整的 url | 仅域名     | 仅域名     |
| `"same-origin"`                                 | 完整的 url | -          | -          |
| `"strict-origin"`                               | 仅域名     | 仅域名     | -          |
| `"strict-origin-when-cross-origin"`             | 完整的 url | 仅域名     | -          |
| `"unsafe-url"`                                  | 完整的 url | 完整的 url | 完整的 url |

假如说我们有一个从网站外部无法观察的带有 URL 结构的管理区域

如果我们发送了一个跨域的 `fetch`，然后它默认地发送带有我们网页完整 url 的 `Referer` 头部。(当我们从 HTTPS 向 HTTP 发送请求的除外，这种情况下是没有 `Referer` )

比如 `Referer: https://javascript.info/admin/secret/paths`。

如果我们想要其他网址只知道域名部分，而不是 URL 的路径，我们可以这样设置选项：

```javascript
fetch('https://another.com/page', {
  // ...
  referrerPolicy: "origin-when-cross-origin" // Referer: https://javascript.info
});
```

我们可以把它放在所有 `fetch` 的调用，也可以整合进我们项目所有用于请求和内部使用 `fetch` 的 JavaScript 库。

与默认行为相比较，它的唯一区别是跨域请求的 `fetch` 只发送 URL 的域名部分(比如 `https://javascript.info`，没有路径)。对于同源请求，我们仍然能得到完整的 `Referer` (也许在 debug 中有用)。

------

**来源协议 (Referrer policy) 不只用于 `fetch`**

在 [规范](https://w3c.github.io/webappsec-referrer-policy/) 中描述的来源协议，不只是用于 `fetch`，它用处更广泛。

具体来说，它可以使用 `Referrer-Policy` 的 HTTP 头部信息给整个页面设置默认来源协议，或者使用 `<a rel="noreferrer">` 给单一链接设置。


##### [mode](https://javascript.info/fetch-api#mode)

`mode` 选项服务类似安全守卫，用以阻止跨域请求：

- **`"cors"`** -- 默认值，允许跨域请求，可见于 <info:fetch-crossorigin>，
- **`"same-origin"`** -- 禁止跨域请求，
- **`"no-cors"`** -- 只允许简单的跨域请求。

当 `fetch` 的 url 来自于第三方，我们想要一个 "停电开关" 来限制跨域能力时，这也许会很有用。

##### [credentials](https://javascript.info/fetch-api#credentials)

`credentials` 选项确定 `fetch` 是否应该在请求中发送 cookies 和 HTTP-Authorization 头部信息。

- **`"same-origin"`** -- 默认值，在跨域请求中不发送，
- **`"include"`** -- 总是发送，需要在跨域服务器中设置 `Accept-Control-Allow-Credentials` 来使 JavaScript 能够接受响应，这部分在这一章节<info:fetch-crossorigin> 有所讨论，
- **`"omit"`** -- 不发送，即使在同源请求。

##### [cache](https://javascript.info/fetch-api#cache)

`fetch` 请求会默认地利用标准的 HTTP 缓存。就是说，它遵从 `Expires`， `Cache-Control` 头部信息，发送 `If-Modified-Since`，和其他头部信息。就像常规的 HTTP 请求。

`cache` 选项允许无视 HTTP 缓存或者微调它的用法：

- **`"default"`** -- `fetch` 使用标准的 HTTP 缓存规则和头部信息，
- **`"no-store"`** -- 完全无视 HTTP 缓存，如果我们设置了头部信息 `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, 或者 `If-Range`，这个模式会成为默认值，
- **`"reload"`** -- 不从 HTTP 缓存获取结果(如果有)，但使用响应填充缓存(如果响应头允许)，
- **`"no-cache"`** -- 如果有一个已缓存的响应则创建一个有条件的请求，否则创建一个常规的请求。使用响应填充 HTTP 缓存，
- **`"force-cache"`** -- 从 HTTP 缓存使用一个响应，即使该缓存已过时。如果在 HTTP 缓存中无响应，则创建一个常规的 HTTP 请求，
- **`"only-if-cached"`** -- 从 HTTP 缓存使用一个响应，即使该缓存已过时。如果在 HTTP 缓存中无响应，则报错。只有当 `mode` 为 `same-origin` 时生效。


##### [redirect](https://javascript.info/fetch-api#redirect)

通常来说, `fetch` 直接随着 HTTP 重定向，比如 301，302等等。

`redirect` 选项允许改变这个情况:

- **`"follow"`** -- 默认值, 随着 HTTP 重定向,
- **`"error"`** -- 如果 HTTP 重定向则报错,
- **`"manual"`** -- 不随着 HTTP 重定向，但 `response.url` 会是一个新的 URL，然后 `response redirectd` 会变为 `true`，所以我们能够手动表现重定向到新的 URL (如果需要的话)。

##### [integrity](https://javascript.info/fetch-api#integrity)

`integrity` 选项允许检查响应是否符合已知的校验和。

正如在[规范](https://w3c.github.io/webappsec-subresource-integrity/)描述的，支持的哈希函数 (hash-functions) SHA-256，SHA-384， 和 SHA-512，也许还有其他，这取决于浏览器。

比如，我们下载一个文件，并且我们知道它的 SHA-256 校验和是 "abcdef" (当然，一个真的校验和更长)。

我们可以把它放在 `integrity` 选项中，就像这样:

```js
fetch('http://site.com/file', {
  integrity: 'sha256-abcdef'
});
```

然后 `fetch` 会自己计算 SHA-256 并且比较我们的字符串。假如匹配错误，则会报错。

##### [keepalive](https://javascript.info/fetch-api#keepalive)

`keepalive` 选项表示请求是否会使初始化后的网页“失活”。

比如，我们收集当前用户是如何使用我们的网页的(点击鼠标，看过的页面碎片)数据，来分析并提升用户体验。

当用户离开我们的网页时 -- 我们希望能够在服务器中储存数据。

为此，我们可以使用事件 `window.onunload`:

```js run
window.onunload = function() {
  fetch('/analytics', {
    method: 'POST',
    body: "statistics",
    keepalive: true
  });
};
```

正常来说，当一个文档卸载时，所有相关联的网络请求都会被取消。但是 `keepalive` 选项告诉浏览器在后台执行请求，即使它离开了页面。所以这个选项对于我们的请求成功是至关重要的。

它有一些限制：
- 我们无法发送太大的数据：`keepalive` 请求的容量限制为 64kb。
    - 如果收集了太多数据，我们可以将其分包，按规律发送出去，所以不会留下太多数据在最后 `onunload` 请求。
    - 限制是对当前进行中的**所有请求的**。所以我们无法通过创建 100 个请求，每个 64kb 这样作弊。
- 如果请求是来自 `onunload`，我们无法处理服务器响应（就只能发送请求，是这个意思吧？？？），因为文档在那个时候已经卸载，函数无法工作。
    - 通常，服务器会对此请求发送空响应，因此这不是问题。

#### 3.7URL 对象

内置的 [URL](https://url.spec.whatwg.org/#api) 类为创建和解析 URL 提供了非常方便的接口。

没有一个网络方法一定要使用 `URL` 对象，因为只使用字符串就已经足够了。因此从技术上来讲我们没有必要使用 `URL`。但是有些时候 `URL` 对象真的很有用。

##### [创建 URL 对象](https://zh.javascript.info/url#chuang-jian-url-dui-xiang)

创建新 URL 对象的语法：

```javascript
new URL(url, [base])
```

- **`url`** —— URL 字符串（string）或者路径（path）（如果 base 被设置，我们会在下面介绍）。
- **`base`** —— 可选的 base，如果设置了此参数并且 `url` 只有路径，那么就会根据这个 `base` 生成 URL。

例如，下面两个 URL 是相同的：

```javascript
let url1 = new URL('https://javascript.info/profile/admin');
let url2 = new URL('/profile/admin', 'https://javascript.info');

alert(url1); // https://javascript.info/profile/admin
alert(url2); // https://javascript.info/profile/admin
```

转到相对于当前 URL 的路径：

```javascript
let url = new URL('https://javascript.info/profile/admin');
let testerUrl = new URL('tester', url);

alert(testerUrl); // https://javascript.info/profile/tester
```

`URL` 对象允许我们随时访问其组件，因此这是一个解析 URL 的好办法，例如：

```javascript
let url = new URL('https://javascript.info/url');

alert(url.protocol); // https:
alert(url.host);     // javascript.info
alert(url.pathname); // /url
```

这是其组件列表：

![image-20191212144122914](第三章.assets/image-20191212144122914.png)

- `href` 是完整的 URL，与 `url.toString()` 相同
- `protocol` 以冒号字符 `:` 结尾
- `search` – 以问号 `?` 开始的一串参数
- `hash` 以哈希字符 `#` 开始
- 如果存在 HTTP 身份验证的话，还会有 `user` 和 `password` 属性：`http://login:password@site.com`（图片上没有，很少使用它）。

------

**我们可以在任意位置用 `URL` 代替字符串**

我们可以在 `fetch` 或者 `XMLHttpRequest` 中使用 `URL` 对象，几乎在任何能使用字符串 URL 的地方都能使用 `URL` 对象。

在绝大多数方法中，它会自动转换为字符串。

##### [搜索参数（SearchParams）“?…”](https://zh.javascript.info/url#sou-suo-can-shu-searchparams)

假设我们想要创建一个具有给定搜索参数的 URL，例如：`https://google.com/search?query=JavaScript`。

我们可以在 URL 字符串中提供他们：

```javascript
new URL('https://google.com/search?query=JavaScript')
```

……但是如果参数中包含空格，非拉丁字母等等（具体参见下面），参数中就要被编码。

因此，有一个 URL 属性用于解决这个问题：`url.searchParams`，[URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) 类型的对象。

它为搜索参数提供了简便的的方法：

- **`append(name, value)`** —— 添加参数，
- **`delete(name)`** —— 移除参数，
- **`get(name)`** —— 获取参数，
- **`getAll(name)`** —— 获取相同 `name` 的所有参数（这是可行的，例如 `?user=John&user=Pete`），
- **`has(name)`** —— 检查参数是否存在，
- **`set(name, value)`** —— set/replace 参数，
- **`sort()`** —— 按 name 排序参数，很少使用，
- ……并且是可迭代的，类似于 `Map`。

例如：

```javascript
let url = new URL('https://google.com/search');
url.searchParams.set('q', 'test me!'); // 添加有空格和 ! 参数

alert(url); // https://google.com/search?q=test+me%21

url.searchParams.set('tbs', 'qdr:y'); // 这个参数指定 Google Search 的日期范围

alert(url); // https://google.com/search?q=test+me%21&tbs=qdr%3Ay

// 遍历搜索参数（解码（decoded））
for(let [name, value] of url.searchParams) {
  alert(`${name}=${value}`); // q=test me!，然后是 tbs=qdr:y
}
```

##### [编码（encoding）](https://zh.javascript.info/url#bian-ma-encoding)

[RFC3986](https://tools.ietf.org/html/rfc3986) 标准定义了哪些字符是允许的，哪些不是。

下面这些是不允许的，必须要编码才可以，例如非拉丁字母，空格 —— 以它们的 UTF-8 代码代替，前缀为 `%`，例如 `%20`（基于历史原因，空格可以通过 `+` 编码，因此在 URL 中也可以这样做）。

好消息是 `URL` 对象能自动处理这些。我们仅需提供未编码的参数，然后将 URL 转换为字符串：

```javascript
// 在这个例子中使用一些 cyrillic 字符

let url = new URL('https://ru.wikipedia.org/wiki/Тест');

url.searchParams.set('key', 'ъ');
alert(url); //https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82?key=%D1%8A
```

正如所见，URL 路径中的 `Тест` 和 `ъ` 参数都被编码。

###### [编码字符串](https://zh.javascript.info/url#bian-ma-zi-fu-chuan)

如果我们使用字符串而不是 URL 对象，此时我们可以使用内建函数手动编码：

- [encodeURI](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) – 编码整个 URL。
- [decodeURI](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI) – 解码为未编码前的状态。
- [encodeURIComponent](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) – 编码 URL 组件，例如搜索参数，或者 hash 或者 pathname。
- [decodeURIComponent](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) – 解码为未编码前的状态。

`encodeURIComponent` 和 `encodeURI` 之间有什么区别？

如果我们看看 URL 就容易理解它们之间的差异，将它分隔为如上图中的组件形式：

```none
http://site.com:8080/path/page?p1=v1&p2=v2#hash
```

正如所见，`:`，`?`，`=`，`&`，`#` 这类字符在 URL 中是允许的。而其他的，包括非拉丁字母和空格，则必须被编码。

这就是 `encodeURI` 所作的事情：

```javascript
// 在 URL 路径中使用 cyrcillic 字符
let url = encodeURI('http://site.com/привет');

// 每个 cyrillic 都被以两个 %xx 的形式编码
// 它们一起组成了字符的 UTF-8 代码
alert(url); // http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82
```

……另一方面，我们看看单个的 URL 组件，比如搜索参数，我们应该编码更多的字符，即被用来格式化 URL 组件的 `?`，`=`和 `&`。

这就是 `encodeURIComponent` 所做的事情。它编码与 `encodeURI` 相同的字符，以及许多其他字符，以使得结果值在任何 URL 组件中都可以安全使用。

例如：

```javascript
let music = encodeURIComponent('Rock&Roll');

let url = `https://google.com/search?q=${music}`;
alert(url); // https://google.com/search?q=Rock%26Roll
```

相较于 `encodeURI`：

```javascript
let music = encodeURI('Rock&Roll');

let url = `https://google.com/search?q=${music}`;
alert(url); // https://google.com/search?q=Rock&Roll
```

我们可以看到，`encodeURI` 不会编码 `&`，因为这是整个 URL 中合法的字符。

但是我们应该在搜索参数中编码 `&`，否则，我们得到的是 `q=Rock&Roll` —— 实际上是 `q=Rock` 加上一些模糊的参数 `Roll`。其结果和预期不同。

因此，对于每个搜索参数，我们应该使用 `encodeURIComponent` 将其准确的插入 URL 字符串。最安全的是编码 name 和 value，除非我们能完全保证参数中只有一个允许的字符。

###### [为什么要用 URL？](https://zh.javascript.info/url#wei-shi-mo-yao-yong-url)

很多旧的代码使用这些函数，这些函数有时候很方便，不会导致错误。

但是在现代代码中，建议使用 [URL](https://url.spec.whatwg.org/#url-class) 和 [URLSearchParams](https://url.spec.whatwg.org/#interface-urlsearchparams) 类。

其中一个理由是：它们都是基于最新的 URI 标准：[RFC3986](https://tools.ietf.org/html/rfc3986)，而 `encode*` 函数是基于过时的 [RFC2396](https://www.ietf.org/rfc/rfc2396.txt) 标准。

例如，IPv6 地址以不同方式处理：

```javascript
// IPv6 地址的合法 URL
let url = 'http://[2607:f8b0:4005:802::1007]/';

alert(encodeURI(url)); // http://%5B2607:f8b0:4005:802::1007%5D/
alert(new URL(url)); // http://[2607:f8b0:4005:802::1007]/
```

正如所见，`encodeURI` 取代了方括号 `[...]`，这是不正确的，原因是：在 RFC2396 (August 1998) 时代 IPv6 URL 还不存在。

这种情况很少见，`encode*` 函数大部分时间都能正常使用，这只是偏好使用新 API 的其中一个原因。

#### 3.8XMLHttpRequest

`XMLHttpRequest` 是 JavaScript 中发送 HTTP 请求的浏览器内置对象。

虽然它的名字里面有“XML”，但它可以操作任何数据，而不仅仅是 XML 格式。我们可以用它来上传/下载文件，跟踪进度等等。

现如今，我们有一个更为现代的方式叫做 `fetch`，它的出现使得 `XMLHttpRequest` 渐渐被弃用。

在现代 web 开发中，出于以下三种原因，我们可能会用 `XMLHttpRequest`：

1. 历史原因：我们需要使用 `XMLHttpRequest` 支持现有脚本。
2. 我们需要兼容老旧的浏览器，并且不想用 polyfills（例如为了让脚本更小）。
3. 我们需要一些 `fetch` 目前无法做到的事情，比如跟踪上传进度。

这些术语听起来都很熟悉是么？如果是那么请继续阅读下面 `XMLHttpRequest` 内容。如果还不是很熟悉的话，那么请先阅读关于 [Fetch](https://zh.javascript.info/fetch) 的基础内容。

##### [XMLHttpRequest 基础](https://zh.javascript.info/xmlhttprequest#xmlhttprequest-ji-chu)

XMLHttpRequest 有两种执行模式：同步（synchronous） 和 异步（asynchronous）。

我们首先来看看最常用的异步模式：

发送请求需要 3 个步骤：

1. 创建 `XMLHttpRequest`：

   ```javascript
   let xhr = new XMLHttpRequest(); // 构造函数没有参数
   ```

2. 初始化 `XMLHttpRequest`：

   ```javascript
   xhr.open(method, URL, [async, user, password])
   ```

   在 `new XMLHttpRequest` 之后我们通常调用 `xhr.open` 函数。它指定了请求的主要参数：

   - `method` — HTTP 方法。通常是 `"GET"` 或者 `"POST"`。
   - `URL` — 要执行请求（request）的 URL 字符串，可以是 [URL](https://zh.javascript.info/url) 对象。
   - `async` — 如果显式的设置为 `false`，那么请求将会以同步的方式处理，我们稍后会讨论它。
   - `user`，`password` — HTTP 基本身份认证（如果需要的话）的登录名和密码。

   请注意。调用 `xhr.open` 函数的时候并不会建立连接。它的作用仅仅是作为当前请求的配置，而网络活动要到 `send` 调用后才开启。

3. 发送请求。

   ```javascript
   xhr.send([body])
   ```

   这个方法建立连接，并发送请求到服务器。可选参数 `body` 包含了请求主体。

   我们稍后会看到一些不同请求方式的示例，比如 `GET` 没有请求体。而 `POST` 这类请求方式会用 `body` 来发送数据到服务器。

4. 监听响应事件。

   这三个事件是最常用的：

   - `load` — 当请求结果已经返回，包括像 404 这样的 HTTP 错误。
   - `error` — 当无法完成请求时，比如网络中断或者无效的 URL。
   - `progress` — 下载期间定时触发，报告已经下载了多少。

   ```javascript
   xhr.onload = function() {
     alert(`Loaded: ${xhr.status} ${xhr.response}`);
   };
   
   xhr.onerror = function() { // 只有在请求无法完成时才会触发
     alert(`Network Error`);
   };
   
   xhr.onprogress = function(event) { // 定时触发
     // event.loaded - 已经下载了多少字节
     // event.lengthComputable = true 当服务器返回了 Content-Length 响应头时
     // event.total - 总字节数（如果 lengthComputable 为 true）
     alert(`Received ${event.loaded} of ${event.total}`);
   };
   ```

下面是一个完整的示例。它从服务器加载 `/article/xmlhttprequest/example/load`，并显示加载进度：

```javascript
// 1. 创建一个新的 XMLHttpRequest 对象
let xhr = new XMLHttpRequest();

// 2. 配置该对象：对 URL /article/.../load 采用 GET 方式请求数据
xhr.open('GET', '/article/xmlhttprequest/example/load');

// 3. 通过网络发送请求数据
xhr.send();

// 4. 当收到响应数据的时候，下面这个函数就会被调用
xhr.onload = function() {
  if (xhr.status != 200) { // 分析响应的状态码
    alert(`Error ${xhr.status}: ${xhr.statusText}`); // 比如 404：Not Found
  } else { // 显示结果
    alert(`Done, got ${xhr.response.length} bytes`); // 响应文本是服务器传回的数据
  }
};

xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    alert(`Received ${event.loaded} of ${event.total} bytes`);
  } else {
    alert(`Received ${event.loaded} bytes`); // 没有 Content-Length
  }

};

xhr.onerror = function() {
  alert("Request failed");
};
```

一旦服务器有了响应，我们可以在下面这些请求对象的属性中获取相关的返回结果：

- `status`

  HTTP 状态码（一个数字）：`200`，`404`，`403` 等等，如果出现非 HTTP 错误，它的结果为 `0`。

- `statusText`

  HTTP 状态消息（字符串）：如果状态码是 `200` 的话它的消息值通常为 `OK`，`404` 对应的值为 `Not Found`，`403` 对应的值为 `Forbidden`。

- `response`（以前的脚本可能用的是 `responseText`）

  服务器响应。

我们还可以使用相应的属性指定超时（timeout）时间：

```javascript
xhr.timeout = 10000; // timeout 单位是 ms，此处即 10 秒
```

如果在给定时间内请求没有成功执行，请求就会被取消，并且触发 `timeout` 事件。

------

**URL 搜索参数（URL search parameters）**

要传递诸如 `?name=value` 这样的 URL 参数，并确保参数被正确编码，我们可以使用 [URL](https://zh.javascript.info/url) 对象：

```javascript
let url = new URL('https://google.com/search');
url.searchParams.set('q', 'test me!');

// 参数 'q' 被编码
xhr.open('GET', url); // https://google.com/search?q=test+me%21
```

##### [响应类型](https://zh.javascript.info/xmlhttprequest#xiang-ying-lei-xing)

我们可以使用 `xhr.responseType` 属性来设置响应格式：

- `""` （默认） — 响应格式为字符串，
- `"text"` — 响应格式为字符串，
- `"arraybuffer"` — 响应格式为 `ArrayBuffer`（对于二进制数据，请参见 [ArrayBuffer，二进制数组](https://zh.javascript.info/arraybuffer-binary-arrays)），
- `"blob"` — 响应格式为 `Blob`（对于二进制数据，请参见 [Blob](https://zh.javascript.info/blob)），
- `"document"` — 响应格式为 XML document（可以使用 XPath 和其他 XML 方法），
- `"json"` — 响应格式为 JSON（自动解析）。

例如，我们以 JSON 格式获取响应：

```javascript
let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/example/json');

xhr.responseType = 'json';

xhr.send();

// 响应数据为 {"message": "Hello, world!"}
xhr.onload = function() {
  let responseObj = xhr.response;
  alert(responseObj.message); // Hello, world!
};
```

------

**请注意：**

在旧的脚本中，你可能会看到 `xhr.responseText` 甚至是 `xhr.responseXML` 属性。

基于一些历史原因，我们使用它们来获取字符串或者 XML 文档。现今，我们应该设置格式为 `xhr.responseType`，然后就能获取如上所示的 `xhr.response` 了。

##### [准备状态（Ready states）](https://zh.javascript.info/xmlhttprequest#zhun-bei-zhuang-tai-readystates)

`XMLHttpRequest` 的状态（states）会随着它的处理进度变化而变化。可以用 `xhr.readyState` 来了解当前状态。

[规范](https://xhr.spec.whatwg.org/#states) 中提到的所有状态如下：

```javascript
UNSENT = 0; // 初始化状态
OPENED = 1; // 调用 open 方法
HEADERS_RECEIVED = 2; // 收到响应头
LOADING = 3; // 响应正在被加载（收到数据包）
DONE = 4; // 请求完成
```

`XMLHttpRequest` 对象按顺序传送这些状态：`0` → `1` → `2` → `3` → … → `3` → `4`。在网络中每收到一个数据包，状态 `3`就会被传送一次。

我们可以使用 `readystatechange` 事件来跟踪它们；

```javascript
xhr.onreadystatechange = function() {
  if (xhr.readyState == 3) {
    // 加载
  }
  if (xhr.readyState == 4) {
    // 请求完成
  }
};
```

你可能在古老的代码中发现 `readystatechange` 这样的事件监听器，它的存在是基于一些历史原因，因为在很长一段时间内都没有 `load` 以及其他事件。

如今，它们已被 `load/error/progress` 事件替代。

##### [终止请求（aborting）](https://zh.javascript.info/xmlhttprequest#zhong-zhi-qing-qiu-aborting)

我们可以随时终止请求。调用 `xhr.abort()` 即可：

```javascript
xhr.abort(); // 终止请求
```

它将会触发 `abort` 事件且 `xhr.status` 变为 `0`。

##### [同步请求](https://zh.javascript.info/xmlhttprequest#tong-bu-qing-qiu)

在 `open` 方法中，如果第三个参数 `async` 被设置为 `false`，那么请求就以同步的方式处理。

换句话说就是在 `send()` 阶段 JavaScript 停止执行，并且等到响应被接收时才继续执行剩余的代码。这有点儿像 `alert` 或 `prompt` 命令。

下面重写上面的例子，`open` 函数的第三个参数设置为 `false`：

```javascript
let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/hello.txt', false);

try {
  xhr.send();
  if (xhr.status != 200) {
    alert(`Error ${xhr.status}: ${xhr.statusText}`);
  } else {
    alert(xhr.response);
  }
} catch(err) { // 代替 onerror
  alert("Request failed");
}
```

它可能看起来很不错，但是同步调用很少使用，因为它们会阻塞页面内（in-page）的 JavaScript 直到加载完成。在一些浏览器中，滚动可能无法正常运行。如果一个同步调用执行很长时间，浏览器可能会建议关闭“挂起”（hanging）的页面。

`XMLHttpRequest` 的许多高级功能在同步请求中都无效，比如向其他域发起请求或者设置超时时间。同时，你也可以看到，它们没有进度指示。

基于这些原因，同步请求使用的非常少，几乎是不使用。在此，我们不再讨论它了。

##### [HTTP 头（HTTP-headers）](https://zh.javascript.info/xmlhttprequest#http-tou-httpheaders)

`XMLHttpRequest` 允许发送自定义请求头，并且可以读取服务器发送过来的响应头。

HTTP-headers 有三种方法：

 **`setRequestHeader(name, value)`**

通过给定的 `name` 和 `value` 设置请求头。例如：

```javascript
xhr.setRequestHeader('Content-Type', 'application/json');
```

------

**Headers 的限制**

一些请求头可能由浏览器专门管理，比如，`Referer` 和 `Host`。 参见 [规范](http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method) 以获取更多信息。

为了用户安全和请求的正确性，`XMLHttpRequest` 不允许修改请求头。

------

**不能移除 header**

`XMLHttpRequest` 的另一个特点是无法撤销 `setRequestHeader`。

一旦请求头被设置，它就无法撤销。其他的调用会向请求头中添加信息，但不会覆盖它们。

例如：

```javascript
xhr.setRequestHeader('X-Auth', '123');
xhr.setRequestHeader('X-Auth', '456');

// 请求头可能是：
// X-Auth: 123, 456
```

------

**`getResponseHeader(name)`**

通过给定的 `name` 来获取响应头（除了 `Set-Cookie` 和 `Set-Cookie2`）。

例如：

```javascript
xhr.getResponseHeader('Content-Type')
```

**`getAllResponseHeaders()`**

返回除 `Set-Cookie` 和 `Set-Cookie2` 外的所有响应头。

响应头以单行形式返回，形如：

```none
Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT
```

响应头中的换行符总是 `"\r\n"`（不依赖于操作系统），所以我们可以很轻易地将其分割成单一的响应头部。name 和 value 之间总是会以冒号后跟空格 `": "` 分隔开。这在规范中已经得到修复。

因此，如果我们想要获取具有 name/value 对的对象，我们用一点点 JS 代码来处理它们。

就像这样（假设有两个响应头具有相同的名称，那么后者会覆盖前者）：

```javascript
let headers = xhr
  .getAllResponseHeaders()
  .split('\r\n')
  .reduce((result, current) => {
    let [name, value] = current.split(': ');
    result[name] = value;
    return result;
  }, {});
```

##### [POST, FormData](https://zh.javascript.info/xmlhttprequest#postformdata)

要建立 POST 请求，我们可以使用内置的 [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) 对象。

语法为：

```javascript
let formData = new FormData([form]); // 创建对象，可以用表单元素 <form> 来填充
formData.append(name, value); // 追加一个字段
```

我们可以从一个表单中创建它，如果需要的话还可以`追加（append）`更多的字段：

1. `xhr.open('POST', ...)` — 使用 `POST` 方法。
2. `xhr.send(formData)` 发送表单到服务器。

例如：

```html
<form name="person">
  <input name="name" value="John">
  <input name="surname" value="Smith">
</form>

<script>
  // 从表单中预填充 FormData
  let formData = new FormData(document.forms.person);

  // 追加更多字段
  formData.append("middle", "Lee");

  // 发送它
  let xhr = new XMLHttpRequest();
  xhr.open("POST", "/article/xmlhttprequest/post/user");
  xhr.send(formData);

</script>
```

表单以 `multipart/form-data` 编码发送。

或者，如果我们更喜欢 JSON，那么可以使用 `JSON.stringify` 并以字符串形式发送。

不过，不要忘记设置请求头 `Content-Type: application/json` 哦。许多服务端框架都能自动解码 JSON：

```javascript
let xhr = new XMLHttpRequest();

let json = JSON.stringify({
  name: "John",
  surname: "Smith"
});

xhr.open("POST", '/submit')
xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');

xhr.send(json);
```

`.send(body)` 方法就像一个非常杂食性的动物。它可以发送几乎所有内容，包括 `Blob` 和 `BufferSource` 对象。

##### [上传进度（Upload progress）](https://zh.javascript.info/xmlhttprequest#shang-chuan-jin-du-uploadprogress)

`progress` 事件仅仅在下载阶段工作。

也就是说：如果 `POST` 一些内容，`XMLHttpRequest` 首先上传我们的数据（请求体（request body）），然后下载响应数据。

如果我们正在上传的文件很大，这时我们肯定对追踪上传进度感兴趣。但是 `xhr.onprogress` 在这里并不起作用。

这里有个其他对象 `xhr.upload`，没有方法，专门用于上传事件。

XMLHttpRequest 事件和 `xhr` 类似，但是 `xhr.upload` 可以在上传阶段被触发：

- `loadstart` — 上传开始。
- `progress` — 上传期间定期触发。
- `abort` — 上传终止。
- `error` — 非 HTTP 错误。
- `load` — 上传成功完成。
- `timeout` — 上传超时（如果设置了 `timeout` 属性）。
- `loadend` — 上传操作完成，可能成功也可能失败。

handlers 示例：

```javascript
xhr.upload.onprogress = function(event) {
  alert(`Uploaded ${event.loaded} of ${event.total} bytes`);
};

xhr.upload.onload = function() {
  alert(`Upload finished successfully.`);
};

xhr.upload.onerror = function() {
  alert(`Error during the upload: ${xhr.status}`);
};
```

下面是个应用示例：带有进度指示的文件上传：

```html
<input type="file" onchange="upload(this.files[0])">

<script>
function upload(file) {
  let xhr = new XMLHttpRequest();

  // 追踪上传进度
  xhr.upload.onprogress = function(event) {
    console.log(`Uploaded ${event.loaded} of ${event.total}`);
  };

  // 跟踪完成：不论成功与否
  xhr.onloadend = function() {
    if (xhr.status == 200) {
      console.log("success");
    } else {
      console.log("error " + this.status);
    }
  };

  xhr.open("POST", "/article/xmlhttprequest/post/upload");
  xhr.send(file);
}
</script>
```

##### [跨域请求（Cross-origin requests）](https://zh.javascript.info/xmlhttprequest#kua-yu-qing-qiu-crossoriginrequests)

`XMLHttpRequest` 可以使用和 [fetch](https://zh.javascript.info/fetch-crossorigin) 相同的跨域资源共享（CORS）策略建立跨域请求。

类似于 `fetch`，默认情况下不会发送 cookies 和 HTTP 认证到其他域。如果要使用它们请设置 `xhr.withCredentials`值为 `true`：

```javascript
let xhr = new XMLHttpRequest();
xhr.withCredentials = true;

xhr.open('POST', 'http://anywhere.com/request');
...
```

参见 [Fetch：跨源请求](https://zh.javascript.info/fetch-crossorigin) 章节以了解更多关于 cross-origin headers 的信息。

##### [总结](https://zh.javascript.info/xmlhttprequest#zong-jie)

使用 `XMLHttpRequest` GET 方式请求数据的典型代码：

```javascript
let xhr = new XMLHttpRequest();

xhr.open('GET', '/my/url');

xhr.send();

xhr.onload = function() {
  if (xhr.status != 200) { // HTTP 出错？
    // 处理错误
    alert( 'Error: ' + xhr.status);
    return;
  }

  // 从 xhr.response 中获取响应
};

xhr.onprogress = function(event) {
  // 报告进度
  alert(`Loaded ${event.loaded} of ${event.total}`);
};

xhr.onerror = function() {
  // 处理非 HTTP 错误（如网络中断）
};
```

实际上还有更多事件，[现代规范](http://www.w3.org/TR/XMLHttpRequest/#events)中列出了它们（按生命周期排序）：

- `loadstart` — 请求开始。
- `progress` — 一个响应数据包到达，此时整个响应体都在 `responseText` 里。
- `abort` — 请求被 `xhr.abort()` 取消。
- `error` — 发生连接错误，例如，域名错误。不会响应诸如 404 这类的 HTTP 错误。
- `load` — 请求成功完成。
- `timeout` — 请求超时被取消（仅仅发生在 timeout 被设置的情况下）。
- `loadend` — 在 `load`，`error`，`timeout` 或者 `abort` 之后触发。

`error`，`abort`，`timeout` 和 `load` 事件是互斥的，即一次只能有一个事件发生。

最常用的事件是加载完成（load completion）（`load`），加载失败（load failure）（`error`），或者我们可以只用 `loadend` 处理程序来检查响应，看看其发生了什么。

我们还了解了一些其他事件：`readystatechange`。由于历史原因，它在规范建立之前就已经出现。现如今已经没有必要使用他们了，我们可以用新的事件代替它，但是在旧的代码中仍然比较常见。

如果我们需要专门追踪上传，那么我们需要在 `xhr.upload` 对象上监听同样的事件。

#### 3.9可恢复的（resumable）文件上传

使用 `fetch` 方法来上传文件相当容易。

当文件上传过程中连接丢失，此时如何恢复上传呢？目前还没有针对此问题的内建选项，但是我们有实现它的一些方法。

当我们上传大型文件的时候（如果我们可能需要恢复），我们期待可恢复上传应带有上传进度指示。由于 `fetch` 不允许追踪上传进度，我们将会使用 [XMLHttpRequest](https://zh.javascript.info/xmlhttprequest)。

##### [不太实用的进度事件](https://zh.javascript.info/resume-upload#bu-tai-shi-yong-de-jin-du-shi-jian)

要恢复上传，我们需要知道在连接丢失前已经上传了多少。

我们有 `xhr.upload.onprogress` 来追踪上传进程。

不幸的是，它在这里没什么作用，它在数据发送 **sent** 完成时触发，但是它真的被服务器接收了吗？浏览器并不知道。

或许它只是被本地代理缓冲（buffered），或是有可能远程服务器处理进程宕机无法处理它们，亦或是当连接断开时它刚刚从中间丢失，且没有到达服务器。

因此，这个事件只是对于显示一个漂亮的进度条来说很有用。

要恢复上传，我们需要知道服务器具体接收了多少字节。只有服务器能告诉我们它接收了多少。

##### [算法](https://zh.javascript.info/resume-upload#suan-fa)

1. 首先，我们创建一个独一无二的标识符作为我们上传的文件 id，例如：

   ```javascript
   let fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;
   ```

   这对恢复上传很有用，它能告诉服务器我们我们要恢复的文件是什么。

2. 发送请求到服务器，获取该文件已经上传了多少字节，就像这样：

   ```javascript
   let response = await fetch('status', {
     headers: {
       'X-File-Id': fileId
     }
   });
   
   // 服务器已有的字节
   let startByte = +await response.text();
   ```

   这假设服务器通过 `X-File-Id` 头跟踪文件上传。应该在服务端实现。

3. 然后我们可以使用 `Blob` 方法 `slice` 来自 `startByte` 的要发送的文件：

   ```javascript
   xhr.open("POST", "upload", true);
   
   // 发送文件 id，这样服务器就能知道要恢复哪个文件
   xhr.setRequestHeader('X-File-Id', fileId);
   // 发送我们正在恢复的字节，因此服务器知道我们正在恢复文件
   xhr.setRequestHeader('X-Start-Byte', startByte);
   
   xhr.upload.onprogress = (e) => {
     console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);
   };
   
   // 文件可以来自于 input.files[0] 或者其他资源
   xhr.send(file.slice(startByte));
   ```

   这里我们将服务器的文件 id 作为 `X-File-Id` 发送，此时服务器就知道我们正在上传哪个文件，并且起始字节为 `X-Start-Byte`，因此服务器知道我们并不是从头开始上传，而是恢复文件。

   服务器应该检查它的记录，如果这个文件之前上传过且当前上传大小是 `X-Start-Byte`，此时将数据附加到原来文件上。

这是用 Node.js 写的客户端和服务端的 demo。

在这个网页上，它只有部分能工作，因为 Node.js 位于另一个服务 Nginx 后面，该服务器缓冲上传过程，当完全上传后才传递给 Node.js。

但是你可以下载这些代码，在本地运行以进行完整演示：

**server.js**

```javascript
let http = require('http');
let static = require('node-static');
let fileServer = new static.Server('.');
let path = require('path');
let fs = require('fs');
let debug = require('debug')('example:resume-upload');

let uploads = Object.create(null);

function onUpload(req, res) {

  let fileId = req.headers['x-file-id'];
  let startByte = req.headers['x-start-byte'];

  if (!fileId) {
    res.writeHead(400, "No file id");
    res.end();
  }

  // 文件位置 “nowhere”
  let filePath = '/dev/null';
  // 可以使用真实路径替代，例如：
  // let filePath = path.join('/tmp', fileId);

  debug("onUpload fileId: ", fileId);

  // 初始化新 upload
  if (!uploads[fileId]) uploads[fileId] = {};
  let upload = uploads[fileId];

  debug("bytesReceived:" + upload.bytesReceived + " startByte:" + startByte)

  let fileStream;

  // 如果 startByte 是 0 或者没有设置，就创建一个新文件，否则检查文件大小并追加到已存在的文件上
  if (!startByte) {
    upload.bytesReceived = 0;
    fileStream = fs.createWriteStream(filePath, {
      flags: 'w'
    });
    debug("New file created: " + filePath);
  } else {
    // 我们也可以检查磁盘（on-disk）文件大小
    if (upload.bytesReceived != startByte) {
      res.writeHead(400, "Wrong start byte");
      res.end(upload.bytesReceived);
      return;
    }
    // 追加到已存在的文件上
    fileStream = fs.createWriteStream(filePath, {
      flags: 'a'
    });
    debug("File reopened: " + filePath);
  }


  req.on('data', function(data) {
    debug("bytes received", upload.bytesReceived);
    upload.bytesReceived += data.length;
  });

  // 将请求体发送到文件
  req.pipe(fileStream);

  // 当请求完成时，所有数据都被写入磁盘
  fileStream.on('close', function() {
    if (upload.bytesReceived == req.headers['x-file-size']) {
      debug("Upload finished");
      delete uploads[fileId];

      // 可以对上传的文件进行一些处理

      res.end("Success " + upload.bytesReceived);
    } else {
      // 连接丢失，我们留下未完成的文件
      debug("File unfinished, stopped at " + upload.bytesReceived);
      res.end();
    }
  });

  // 在 I/O 错误的情况下 —— 完成请求
  fileStream.on('error', function(err) {
    debug("fileStream error");
    res.writeHead(500, "File error");
    res.end();
  });

}

function onStatus(req, res) {
  let fileId = req.headers['x-file-id'];
  let upload = uploads[fileId];
  debug("onStatus fileId:", fileId, " upload:", upload);
  if (!upload) {
    res.end("0")
  } else {
    res.end(String(upload.bytesReceived));
  }
}


function accept(req, res) {
  if (req.url == '/status') {
    onStatus(req, res);
  } else if (req.url == '/upload' && req.method == 'POST') {
    onUpload(req, res);
  } else {
    fileServer.serve(req, res);
  }

}




// -----------------------------------

if (!module.parent) {
  http.createServer(accept).listen(8080);
  console.log('Server listening at port 8080');
} else {
  exports.accept = accept;
}
```

**uploader.js**

```javascript
class Uploader {

  constructor({file, onProgress}) {
    this.file = file;
    this.onProgress = onProgress;

    // 创建文件的唯一标识 fileId
    // 我们还可以添加用户会话标识符（如果有的话）来使它更唯一
    this.fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;
  }

  async getUploadedBytes() {
    let response = await fetch('status', {
      headers: {
        'X-File-Id': this.fileId
      }
    });

    if (response.status != 200) {
      throw new Error("Can't get uploaded bytes: " + response.statusText);
    }

    let text = await response.text();

    return +text;
  }

  async upload() {
    this.startByte = await this.getUploadedBytes();

    let xhr = this.xhr = new XMLHttpRequest();
    xhr.open("POST", "upload", true);

    // 发送文件 id，这样服务器就知道要恢复哪个文件
    xhr.setRequestHeader('X-File-Id', this.fileId);
    // 发送我们开始进行恢复的起点字节（即之前已经上传的字节数），这样服务器就知道我们正在恢复中
    xhr.setRequestHeader('X-Start-Byte', this.startByte);

    xhr.upload.onprogress = (e) => {
      this.onProgress(this.startByte + e.loaded, this.startByte + e.total);
    };

    console.log("send the file, starting from", this.startByte);
    xhr.send(this.file.slice(this.startByte));

    // 返回值
    //   如果 upload 成功，返回 true，
    //   如果终止，返回 false
    // 如果出现错误，抛出
    return await new Promise((resolve, reject) => {

      xhr.onload = xhr.onerror = () => {
        console.log("upload end status:" + xhr.status + " text:" + xhr.statusText);

        if (xhr.status == 200) {
          resolve(true);
        } else {
          reject(new Error("Upload failed: " + xhr.statusText));
        }
      };

      // 仅在 xhr.abort() 被调用后才会触发 onabort
      xhr.onabort = () => resolve(false);

    });

  }

  stop() {
    if (this.xhr) {
      this.xhr.abort();
    }
  }

}
```

**index.html**

```html
<!DOCTYPE HTML>

<script src="uploader.js"></script>

<form name="upload" method="POST" enctype="multipart/form-data" action="/upload">
  <input type="file" name="myfile">
  <input type="submit" name="submit" value="Upload (Resumes automatically)">
</form>

<button onclick="uploader.stop()">Stop upload</button>


<div id="log">Progress indication</div>

<script>
  function log(html) {
    document.getElementById('log').innerHTML = html;
    console.log(html);
  }

  function onProgress(loaded, total) {
    log("progress " + loaded + ' / ' + total);
  }

  let uploader;

  document.forms.upload.onsubmit = async function(e) {
    e.preventDefault();

    let file = this.elements.myfile.files[0];
    if (!file) return;

    uploader = new Uploader({file, onProgress});

    try {
      let uploaded = await uploader.upload();

      if (uploaded) {
        log('success');
      } else {
        log('stopped');
      }

    } catch(err) {
      console.error(err);
      log('error');
    }
  };

</script>
```

正如你所见，现代网络方法在功能上和文件管理器非常接近 —— 控制 headers，进度指示，发送文件片段等等。

#### 3.10长轮询（long polling）

长轮询是与服务器建立持久连接的最简单方法，它不使用任何特定协议，比如 WebSocket 或者服务端事件（Server Side Events）。

它很容易实现，在很多场景下也很好用。

##### [普通轮询（regular Polling）](https://zh.javascript.info/long-polling#pu-tong-lun-xun-regularpolling)

最简单的从服务器获取新信息的方式就是轮询。

也就是说，定期向服务器发出请求：“Hello, I’m here, do you have any information for me?”。例如，10 秒发送一次。

作为响应，服务器首先通知自己客户端在线，然后第二次 —— 发送直到那个时刻的消息包。

这很有效，但是也有些缺点：

1. 消息的传递时间长达 10 秒（每个请求之间）。
2. 即使没有消息，服务器也会每隔 10 秒被请求轰炸一次。对于后端来说，出于性能的考量，这是一个非常大的负担。

因此，如果我们讨论的是一个小型的服务，这种方法是可行的，但是一般来说，它需要一些改进。

##### [长轮询（long polling）](https://zh.javascript.info/long-polling#chang-lun-xun-longpolling)

所谓“长轮询”是一种更好的轮询服务器的方法。

它非常容易实现，并且可以无延迟地传递消息。

其流程为：

1. 发送请求到服务器。
2. 服务器在有消息之前不会关闭连接。
3. 当消息出现 —— 服务器响应请求，并携带相应的数据。
4. 浏览器马上创建一个新的请求。

当浏览器发送一个请求并与服务器建立挂起（pending）连接的情况是此方法的标准。仅仅在传递消息时，才会重新建立连接。

![image-20191212155350743](第三章.assets/image-20191212155350743.png)

如果连接丢失，可能是因为网络错误，浏览器立即发送一个新请求。

发出长请求的客户端 `subscribe` 函数的草图：

```javascript
async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // 连接超时错误，
    // 当连接挂起太长可能会发生，远程服务器或者代理会关闭它
    // 重新连接
    await subscribe();
  } else if (response.status != 200) {
    // 显示错误
    showMessage(response.statusText);
    // 1 秒后重连
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // 得到消息
    let message = await response.text();
    showMessage(message);
    await subscribe();
  }
}

subscribe();
```

你可以看到，`subscribe` 函数发起 fetch 请求，然后等待请求响应并处理它，然后再调用自己。

------

**对于许多的挂起连接，服务器也应该能够很好的处理**

服务器架构必须能够处理许多挂起连接。

某些服务器架构是每个连接对应一个进程。对于许多连接的情况，可能会有许多进程，每个进程占用很多内存。因此连接越多消耗也就越多。

这种情况通常是对于使用 PHP，Ruby 语言的后端，但是从技术上来说，它不是一种语言，而是实现的问题。

使用 Node.js 写的后端通常不会出现这样的问题。

##### [Demo：chat](https://zh.javascript.info/long-polling#demochat)

代码太长，写多了有点卡，请自行移步到官网去学习代码。

##### [使用场景](https://zh.javascript.info/long-polling#shi-yong-chang-jing)

在消息很少的情况下，长轮询很有效。

如果消息比较频繁，那么上面描绘的请求接收（requesting-receiving）消息的图表就会变成锯状（saw-like）。

每条消息都是单独的请求，带有 headers，authentication 等开销。

因此，在这种情况下，首选另一种方法，例如：[Websocket](https://zh.javascript.info/websocket) 或者 [Server Sent Events](https://zh.javascript.info/server-sent-events)。

#### 3.11WebSocket

在 [RFC 6455](http://tools.ietf.org/html/rfc6455) 规范中描述的 `WebSocket` 协议提供了一种在浏览器和服务器之间建立持久连接的通信方法。

一旦 Websocket 连接建立，客户端和服务端就能互相发送数据了。

WebSocket 特别适用于连续数据交换的服务，例如在线游戏，实时交易系统等等。

##### [一个简单例子](https://zh.javascript.info/websocket#yi-ge-jian-dan-li-zi)

要打开 Websocket 连接，我们需要在 url 中使用特殊的协议 `ws` 创建 `new WebSocket`：

```javascript
 let socket = new WebSocket("ws://javascript.info");
```

同样也有一个加密协议 `wss://`。类似于 Websocket 中的 HTTPS。

------

**始终使用 `wss://`**

`wss://` 协议不仅能加密，而且更可靠。

一方面是因为 `ws://` 数据不是加密的，对于任何中间人来说其数据都是可见的。另一方面是因为过去的代理服务还不知道 WebSocket，它们可能因为识别到这个“奇怪的”头而终止连接。

另外，`wss://` 是基于 TLS 的 WebSocket，（类似于 HTTPS 是 HTTP 基于 TLS），传输安全层（transport security layer）加密发送方的数据并在接收方解密，因此它通过代理加密传递。它们看不到传输的内容且会让这些数据通过。

------

当 socket 建立后，我们就应该侦听 socket 上的事件。一共有 4 个事件：

- **`open`** —— 连接建立，
- **`message`** —— 数据接收，
- **`error`** —— Websocket 错误，
- **`close`** —— 连接关闭。

……如果我们想要发送数据，可以使用 `socket.send(data)`。

下面是它的一个例子：

```javascript
let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
  alert("[open] Connection established, send -> server");
  socket.send("My name is John");
};

socket.onmessage = function(event) {
  alert(`[message] Data received: ${event.data} <- server`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
  } else {
    // 例如，服务进程关闭或者网络出现问题
    // 在这种情况下 event.code 通常是 1006
    alert('[close] Connection died');
  }
};

socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
};
```

出于演示目的，这里有一个用 Node.js 写的小型服务器 [server.js](https://zh.javascript.info/article/websocket/demo/server.js)，你可以运行它以体验上面的例子。它以“hello”响应，等待 5 秒后关闭连接。

所以你看到的事件顺序为：`open` → `message` → `close`。

这就是 WebSocket，我们已经可以使用 WebSocket 通信了。很简单，不是吗？

现在我们更深入讨论一下。

##### [建立 WebSocket](https://zh.javascript.info/websocket#jian-li-websocket)

当 `new WebSocket(url)` 被创建后，它立即开始连接。

在连接期间，浏览器（通过请求头）问服务器：“你支持 Websocket 吗？”如果服务器回复说“我支持 Websocket”，那么通信就以 Websocket 协议继续进行，而不是 HTTP 形式。

![image-20191212161620185](第三章.assets/image-20191212161620185.png)

这是一个浏览器请求的例子：`new WebSocket("wss://javascript.info/chat")`。

```none
GET /chat
Host: javascript.info
Origin: https://javascript.info
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13
```

- `Origin` —— 客户端页面的 origin，例如：`https://javascript.info`。WebSocket 对象原生支持 cross-origin。没有特殊的头与限制。以前的服务器不能处理 WebSocket，因此不存在任何兼容性问题。但是 `Origin` 请求头很重要，因为它允许服务器做出决定是否使用 WebSocket 与该网站通信。
- `Connection: Upgrade` —— 表示客户端想要更改协议。
- `Upgrade: websocket` —— 请求更改为“websocket”协议。
- `Sec-WebSocket-Key` —— 浏览器随机生成的安全密钥。
- `Sec-WebSocket-Version` —— WebSocket 协议版本，当前为 13。

------

**无法模拟 WebSocket 握手（handshake）**

我们不能使用 `XMLHttpRequest` 或者 `fetch` 来模拟这种 HTTP 请求，因为 JavaScript 不允许设置这些请求头。

------

如果服务器同意转换为 WebSocket 协议，服务器就会返回响应代码 101：

```none
101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
```

`Sec-WebSocket-Accept` 是 `Sec-WebSocket-Key`，使用特殊的算法重新编码。浏览器以此来确保响应正确的请求。

然后，数据就使用 WebSocket 协议传输，我们很快就会看到它的结构（“frames”）。它和 HTTP 有着本质上的区别。

###### [扩展（extensions）和子协议（subprotocols）](https://zh.javascript.info/websocket#kuo-zhan-extensions-he-zi-xie-yi-subprotocols)

WebSocket 有其他的头 `Sec-WebSocket-Extensions` 和 `Sec-WebSocket-Protocol` 描述扩展和子协议。

例如：

- `Sec-WebSocket-Extensions: deflate-frame` 表示浏览器支持数据压缩。扩展与传输数据有关而与数据本身无关。
- `Sec-WebSocket-Protocol: soap, wamp` 表示我们不仅要传输任何数据，还要传输 [SOAP](http://en.wikipedia.org/wiki/SOAP) 或者 WAMP（“The WebSocket Application Messaging Protocol”）协议内的数据。WebSocket 子协议已经在 [IANA catalogue](http://www.iana.org/assignments/websocket/websocket.xml) 中注册。

`Sec-WebSocket-Extensions` 请求头是浏览器自动发送的，其中包含可能支持的扩展列表。

`Sec-WebSocket-Protocol` 请求头由我们设置：我们确定我们发送的是什么类型的数据。`new WebSocket` 的第二个可选参数就是为此而生，子协议列表为：

```javascript
let socket = new WebSocket("wss://javascript.info/chat", ["soap", "wamp"]);
```

服务器应响应它支持的协议和扩展的列表。

例如，请求如下：

```none
GET /chat
Host: javascript.info
Upgrade: websocket
Connection: Upgrade
Origin: https://javascript.info
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13
Sec-WebSocket-Extensions: deflate-frame
Sec-WebSocket-Protocol: soap, wamp
```

响应：

```none
101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
Sec-WebSocket-Extensions: deflate-frame
Sec-WebSocket-Protocol: soap
```

通过服务器响应可以知道它支持“deflate-frame”扩展以及仅支持 SOAP 的请求子协议。

##### [WebSocket 数据](https://zh.javascript.info/websocket#websocket-shu-ju)

WebSocket 通信由“frames”组成 —— 数据片段，可以从任何一方发送，有以下几种：

- “text frames” —— 包含各方发送给彼此的文本数据。
- “binary data frames” —— 包含各方发送给彼此的二进制数据。
- “ping/pong frames” 被用来检查从服务器发送的连接，浏览器自动响应这些数据。
- “connection close frame” 以及其他服务 frames。

在浏览器里，我们只直接使用文本或者二进制数据。

**WebSocket `.send()` 方法也可以发送文本或者二进制数据。**

一个名为 `socket.send(body)` 的方法允许 `body` 是字符串或者二进制格式，包括 `Blob`，`ArrayBuffer` 等等。不需要额外的设置：直接发送它们就可以了。

**当我们接收到了数据后，文本总是以字符串形式呈现。而对于二进制数据，我们可以选择 `Blob` 和 `ArrayBuffer` 形式。**

`socket.bufferType` 默认为 `"blob"`，因此二进制数据通常以 Blob 形式呈现。

[Blob](https://zh.javascript.info/blob) 是高级的（high-level）二进制对象，它直接与 `<a>`，`<img>` 等其他标签集成，因此以 Blob 为默认形式是合理的行为。但是对于二进制处理，要访问单个数据字节，我们可以将默认的 Blob 修改为 `"arraybuffer"`：

```javascript
socket.bufferType = "arraybuffer";
socket.onmessage = (event) => {
  // event.data 是字符串（如果是文本）或者 arraybuffer（如果是二进制）
};
```

##### [限速（Rate limiting）](https://zh.javascript.info/websocket#xian-su-ratelimiting)

想象一下这种情况：我们的应用生成了很多要发送的数据。但是用户端的网速却很慢，可能是在乡下的移动设备上。

我们可以反复调用 `socket.send(data)`。但是数据将会缓冲（buffered）（储存 stored）在内存中，并且只能在网络速度允许的情况下快速发送出去。

`socket.bufferedAmount` 属性储存此时缓冲的字节数，等待通过网络发送。

我们可以检查它以查看 socket 是否真的可用于传输。

```javascript
// 每 100ms 检查一次 socket 并发送更多数据
// 仅当所有现有的数据都被发送出去
setInterval(() => {
  if (socket.bufferedAmount == 0) {
    socket.send(moreData());
  }
}, 100);
```

##### [连接关闭（Connection close）](https://zh.javascript.info/websocket#lian-jie-guan-bi-connectionclose)

通常，当一方想要关闭连接时（浏览器和服务器都有相同的权限），它们会发送带有状态码（numeric code）和文本形式的原因的 “connection close frame”。

它的方法是：

```javascript
socket.close([code], [reason]);
```

- `code` 是一个特殊的 WebSocket 状态码（可选）
- `reason` 是一个描述关闭连接的原因的字符串（可选）

然后，另外一方通过 `close` 事件处理器获取了状态码和关闭原因，例如：

```javascript
// 关闭方：
socket.close(1000, "Work complete");

// 另一方
socket.onclose = event => {
  // event.code === 1000
  // event.reason === "Work complete"
  // event.wasClean === true（完成关闭）
};
```

常见状态码：

- `1000` —— 默认，正常关闭（如果没有指明 `code` 时使用它），
- `1006` —— 没有办法手动指定这个值，表示连接丢失（没有 close frame）。

以及其他值：

- `1001` —— 一方打算离开，例如：服务器正在关机，或者从浏览器上离开页面，
- `1009` —— 消息太长而不能处理，
- `1011` —— 服务器意外出错，
- ……等等。

请参阅 [RFC6455, §7.4.1](https://tools.ietf.org/html/rfc6455#section-7.4.1) 以了解更多连接关闭状态码。

WebSocket 状态码有点像 HTTP 状态码，但它们是不同的。特别是当我们尝试设置任何小于 `1000` 的状态码时将会出错。

```javascript
// 如果连接断开
socket.onclose = event => {
  // event.code === 1006
  // event.reason === ""
  // event.wasClean === false（没有 closing frame）
};
```

##### [连接状态（Connection state）](https://zh.javascript.info/websocket#lian-jie-zhuang-tai-connectionstate)

要获取连接状态，可以通过 `socket.readyState` 属性值来获取：

- **`0`** —— “CONNECTING”：连接还未建立，
- **`1`** —— “OPEN”：通信中，
- **`2`** —— “CLOSING”：连接关闭中，
- **`3`** —— “CLOSED”：连接已关闭。

##### [Chat 例子](https://zh.javascript.info/websocket#chat-li-zi)

让我们通过浏览器的 WebSocket API 和 Node.js 的 WebSocket 模块 https://github.com/websockets/ws 来回顾一下上述 chat 例子。

HTML：`<form>` 用于发送消息，`<div>` 用于显示接收到的消息：

```html
<!-- 消息 form -->
<form name="publish">
  <input type="text" name="message">
  <input type="submit" value="Send">
</form>

<!-- div 显示消息 -->
<div id="messages"></div>
```

JavaScript 代码也很简单。我们打开一个 socket，然后提交表单 —— `socket.send(message)`，对于传入的消息 —— 附加到 `div#messages` 上即可：

```javascript
let socket = new WebSocket("wss://javascript.info/article/websocket/chat/ws");

// form 发送消息
document.forms.publish.onsubmit = function() {
  let outgoingMessage = this.message.value;

  socket.send(outgoingMessage);
  return false;
};

// div#messages 显示消息
socket.onmessage = function(event) {
  let message = event.data;

  let messageElem = document.createElement('div');
  messageElem.textContent = message;
  document.getElementById('messages').prepend(messageElem);
}
```

服务端代码有点超出我们的范围。我们使用的是浏览器 WebSocket API，服务端有其他库可用。

但它仍然很简单。我们将 Node.js 与 https://github.com/websockets/ws 模块一起用于 Websocket。

服务端算法为：

1. 创建 `clients = new Set()` —— 一系列 sockets。
2. 对于每个可接受的 Websocket，`clients.add(socket)` 并为其消息添加 `message` 事件侦听器。
3. 当接收到消息：迭代所有客户端，并将消息发送给每个人。
4. 当连接关闭时：`clients.delete(socket)`。

```javascript
const ws = new require('ws');
const wss = new ws.Server({noServer: true});

const clients = new Set();

http.createServer((req, res) => {
  // 我们在这里仅处理 Websocket 连接
  // 在实际例子中我们将会有其他代码来处理非 Websocket 请求
  wss.handleUpgrade(req, req.socket, Buffer.alloc(0), onSocketConnect);
});

function onSocketConnect(ws) {
  clients.add(ws);

  ws.on('message', function(message) {
    message = message.slice(0, 50); // 最大消息长度为 50

    for(let client of clients) {
      client.send(message);
    }
  });

  ws.on('close', function() {
    clients.delete(ws);
  });
}
```

你可以从`websocket_chart_demo.zip`测试它。运行之前请记得安装 [Node.js](https://nodejs.org/en/) 和 `npm install ws`。

##### [总结](https://zh.javascript.info/websocket#zong-jie)

WebSocket 是一种在浏览器和服务器之间建立持久连接的现代方式。

- WebSockets 没有跨域限制。
- 浏览器对 WebSockets 支持很好。
- 可以发送/接收字符串和二进制数据。

WebSockets 的 API 很简单。

WebSockets 方法：

- `socket.send(data)`，
- `socket.close([code], [reason])`。

WebSockets 事件：

- `open`，
- `message`，
- `error`，
- `close`。

WebSocket 自身并不包含重新连接（reconnection），身份验证（authentication）和许多其他高级机制。因此有针对于此的客户端/服务端的库，并且可以手动实现这些功能。

有时候，为了将 WebSocket 集成到现有项目中，人们将主 HTTP 服务与 WebSocket 服务并行运行，并且它们之间共享同一个数据库。对于 WebSocket 请求使用一个通向 WebSocket 服务器的子域 `wss://ws.site.com`，而 `https://site.com` 则转到主 HTTP 服务器。

当然，其他集成方式也是可行的。许多服务器（例如 Node.js）可以同时支持 HTTP 和 WebSocket 协议。

#### 3.12Server Sent Events

[Server-Sent Events](https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface) 标准描述了一个内建的类 `EventSource`，它能保持与服务器的连接并允许从中接收事件。

类似于 `WebSocket`，其连接是持久的。

但是两者之间也有几个重要的区别：

| `WebSocket`                                        | `EventSource`                                |
| :------------------------------------------------- | :------------------------------------------- |
| 双向（Bi-directional）：客户端和服务端都能修改消息 | 单向（ One-directional）：仅服务端能发送消息 |
| 二进制和文本数据                                   | 仅文本数据                                   |
| WebSocket 协议                                     | 普通 HTTP 协议                               |

与 `WebSocket` 相比，`EventSource` 是一种与服务器通信的低配版本。

我们为什么要使用它呢？

主要原因是：简单。在许多应用中，`WebSocket` 有点大材小用。

我们需要从服务器接收数据流：可能是聊天消息或者商品价格等等。这是 `EventSource` 擅长之处。它支持自动重新连接，而在 `WebSocket` 中这个功能我们要手动实现。另外，它是一个普通的我们熟知的 HTTP，而不是其他新协议。

##### [获取消息](https://zh.javascript.info/server-sent-events#huo-qu-xiao-xi)

要开始接收消息，我们只需要创建 `new EventSource(url)` 即可。

浏览器将会连接到 `url` 并保持连接开启等待事件到来。

服务器应该响应状态码为 200 并返回响应头 `Content-Type: text/event-stream`，然后保持此连接并以一种特殊的格式写入消息，就像这样：

```none
data: Message 1

data: Message 2

data: Message 3
data: of two lines
```

- `data:` 后为消息文本，冒号后面的空格是可选的。
- 消息以双换行符 `\n\n` 分隔。
- 要发送换行 `\n`，我们可以在要换行的位置添加一个 `data:`（上面的第三条消息）。

在实际开发中，复杂的消息通常是用 JSON 编码后发送。换行符在其中编码为 `\n`，因此不需要多行 `data:` 消息。

例如：

```javascript
data: {"user":"John","message":"First line\n Second line"}
```

……因此我们可以假设一个 `data:` 只包含一条消息。

对每个消息，生成 `message` 事件：

```javascript
let eventSource = new EventSource("/events/subscribe");

eventSource.onmessage = function(event) {
  console.log("New message", event.data);
  // 对于上面的数据，将会打印三次
};

// 或者 eventSource.addEventListener('message', ...)
```

###### [跨域请求](https://zh.javascript.info/server-sent-events#kua-yu-qing-qiu)

`EventSource` 支持跨域请求，就像 `fetch` 任何其他的网络方法。我们可以使用任何 URL：

```javascript
let source = new EventSource("https://another-site.com/events");
```

远程服务器将会获取到 `Origin` 请求头，并且必须以 `Access-Control-Allow-Origin` 响应才能继续。

要传递凭证（credentials），我们应该设置附加选项 `withCredentials`，就像这样：

```javascript
let source = new EventSource("https://another-site.com/events", {
  withCredentials: true
});
```

请参见 [Fetch：跨源请求](https://zh.javascript.info/fetch-crossorigin) 章节以了解更多关于跨域头的细节信息。

##### [重新连接](https://zh.javascript.info/server-sent-events#zhong-xin-lian-jie)

创建之后，`new EventSource` 连接到服务器，如果连接断开 —— 则重新连接。

这很方便，我们不用去关心重新连接的事情。

每次重新连接之间有一点小的延迟，默认为几秒钟。

服务器可以使用 `retry:` 设置需要的延迟响应时间（以毫秒为单位）。

```javascript
retry: 15000
data: Hello, I set the reconnection delay to 15 seconds
```

`retry:` 既可以与某些数据一起出现，也可以作为独立的消息出现。

浏览器需要等待很长时间才能再次重新连接。或者更长，例如：如果浏览器知道（从系统知道的）此时没有网络连接，它可能会等到连接出现，然后重试。

- 如果服务器想要浏览器停止重新连接，那么它应该返回 HTTP 代码 204。
- 如果浏览器想要关闭连接，它应该调用 `eventSource.close()`：

```javascript
let eventSource = new EventSource(...);

eventSource.close();
```

另外，如果响应具有不正确的 `Content-Type` 或者其 HTTP 状态码不是 301，307，200 和 204，则不重新连接。发出 `"error"` 事件的连接，浏览器不会重新连接。

------

**请注意：**

当连接最终被关闭时，就无法再“重新打开”它了。如果我们想再次连接，只需要创建一个新的 `EventSource`。

##### [消息 id](https://zh.javascript.info/server-sent-events#xiao-xi-id)

当一个连接由于网络问题而断开时，客户端和服务器都无法确定哪些消息已经收到哪些没有收到。

要正确的恢复连接，每条消息都应该有一个 `id` 字段，就像这样：

```none
data: Message 1
id: 1

data: Message 2
id: 2

data: Message 3
data: of two lines
id: 3
```

当收到带有 `id` 的消息时，浏览器会：

- 将属性 `eventSource.lastEventId` 设置为其值。
- 重新连接时，使用该 `id` 发送 `Last-Event-ID` 请求头，以便服务器可以重新发送后面的消息。

------

**把 `id:` 放到 `data:` 后**

请注意：`id` 是被服务器附加到 `data` 消息后的，以确保在收到消息后更新 `lastEventId`。

##### [连接状态：readyState](https://zh.javascript.info/server-sent-events#lian-jie-zhuang-tai-readystate)

`EventSource` 对象有 `readyState` 属性，具有下列其中一个值：

```javascript
EventSource.CONNECTING = 0; // 连接中或者重连中
EventSource.OPEN = 1;       // 已连接
EventSource.CLOSED = 2;     // 连接关闭
```

创建对象或者连接断开时，它始终是 `EventSource.CONNECTING`（等于 `0`）。

我们可以查询这个属性以了解 `EventSource` 的状态。

##### [Event 类型](https://zh.javascript.info/server-sent-events#event-lei-xing)

默认情况下 `EventSource` 对象生成三个事件：

- `message` —— 收到消息，可以用 `event.data` 访问。
- `open` —— 打开连接。
- `error` —— 无法建立连接，例如：服务器返回 HTTP 500 状态码。

服务器可以在事件开始时使用 `event: ...` 指定另一种类型事件。

例如：

```none
event: join
data: Bob

data: Hello

event: leave
data: Bob
```

要处理自定义事件，我们必须使用 `addEventListener` 而非 `onmessage`：

```javascript
eventSource.addEventListener('join', event => {
  alert(`Joined ${event.data}`);
});

eventSource.addEventListener('message', event => {
  alert(`Said: ${event.data}`);
});

eventSource.addEventListener('leave', event => {
  alert(`Left ${event.data}`);
});
```

##### [完整例子](https://zh.javascript.info/server-sent-events#wan-zheng-li-zi)

**server.js**

```javascript
let http = require('http');
let url = require('url');
let querystring = require('querystring');

function onDigits(req, res) {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream; charset=utf-8',
    'Cache-Control': 'no-cache'
  });

  let i = 0;

  let timer = setInterval(write, 1000);
  write();

  function write() {
    i++;

    if (i == 4) {
      res.write('event: bye\ndata: bye-bye\n\n');
      clearInterval(timer);
      res.end();
      return;
    }

    res.write('data: ' + i + '\n\n');

  }
}

function accept(req, res) {

  if (req.url == '/digits') {
    onDigits(req, res);
    return;
  }

  fileServer.serve(req, res);

}


if (!module.parent) {
  http.createServer(accept).listen(8080);
} else {
  exports.accept = accept;
}
```

**Index.html**

```html
<!DOCTYPE html>
<script>
let eventSource;

function start() { // 当“Start”按钮被点击
  if (!window.EventSource) {
    // IE 或者很老的浏览器
    alert("The browser doesn't support EventSource.");
    return;
  }

  eventSource = new EventSource('digits');

  eventSource.onopen = function(e) {
    log("Event: open");
  };

  eventSource.onerror = function(e) {
    log("Event: error");
    if (this.readyState == EventSource.CONNECTING) {
      log(`Reconnecting (readyState=${this.readyState})...`);
    } else {
      log("Error has occured.");
    }
  };

  eventSource.addEventListener('bye', function(e) {
    log("Event: bye, data: " + e.data);
  });

  eventSource.onmessage = function(e) {
    log("Event: message, data: " + e.data);
  };
}

function stop() { // 当“Stop”按钮被点击
  eventSource.close();
  log("eventSource.close()");
}

function log(msg) {
  logElem.innerHTML += msg + "<br>";
  document.documentElement.scrollTop = 99999999;
}
</script>

<button onclick="start()">Start</button> Press the "Start" to begin.
<div id="logElem" style="margin: 6px 0"></div>

<button onclick="stop()">Stop</button> "Stop" to finish.
```

##### [总结](https://zh.javascript.info/server-sent-events#zong-jie)

`EventSource` 对象自动建立一个持久的连接并允许服务器通过这个连接发送消息。

它可以:

- 在可调的 `retry` 时间内可以自动重连。
- 使用消息 id 恢复事件，最后收到的标识符在重新连接时以 `Last-Event-ID` 请求头发送出去。
- 当前状态位于 `readyState` 属性中。

这使得 `EventSource` 成为 `WebSocket` 的一个可行替代品，因为 `WebSocket` 更低级（low-level），且缺乏这样内置功能（尽管它们可以被实现）。

在实际应用中，`EventSource` 功能就已经够用了。

`EventSource` 支持所有现代浏览器（除了 IE）。

语法：

```javascript
let source = new EventSource(url, [credentials]);
```

第二个参数只有一个可选项：`{ withCredentials: true }`，它允许发送跨域凭证。

总体跨域安全性与 `fetch` 以及其他网络方法相同。

###### [`EventSource` 对象的属性](https://zh.javascript.info/server-sent-events#eventsource-dui-xiang-de-shu-xing)

- `readyState`

  当前连接状态：为 `EventSource.CONNECTING (=0)`，`EventSource.OPEN (=1)`，`EventSource.CLOSED (=2)`三者之一。

- `lastEventId`

  最后接收的 `id`。重新连接后，浏览器在 `Last-Event-ID` 请求头中发送此 id。

###### [`EventSource` 对象的方法](https://zh.javascript.info/server-sent-events#eventsource-dui-xiang-de-fang-fa)

- `close()`

  关闭连接。

###### [`EventSource` 对象的事件](https://zh.javascript.info/server-sent-events#eventsource-dui-xiang-de-shi-jian)

- `message`

  接收到了消息，消息数据在 `event.data` 中。

- `open`

  连接已建立。

- `error`

  如果出现错误，包括连接丢失（将会自动重连）以及其他致命错误。我们可以检查 `readyState` 以查看是否正在尝试重新连接。

服务器可能在 `event:` 中发送一个自定义事件名称。这类事件应该使用 `addEventListener` 来处理而不是 `on<event>`。

###### [服务器响应格式](https://zh.javascript.info/server-sent-events#fu-wu-qi-xiang-ying-ge-shi)

服务器发送由 `\n\n` 分隔的消息。

一条消息可能有以下字段：

- `data:` —— 消息体，一系列多个 `data` 被解析为单个消息，各个部分由 `\n` 分隔。
- `id:` —— 更新 `lastEventId`，重连时以 `Last-Event-ID` 发送此 id。
- `retry:` —— 建议以 ms 为重新连接的延迟单位。没有办法以 JavaScript 设置它。
- `event:` —— 事件名，必须在 `data:` 之前。

一条消息可能包含任何顺序的一个或多个字段，但是 `id:` 通常是最后一个。


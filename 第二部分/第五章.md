

# 现代javascript教程

## 第2部分：浏览器：文档、事件和接口

### 第五章、加载文档和其他资源

#### 5.1Page: DOMContentLoaded, load, beforeunload, unload

HTML页面的生命周期包含三个重要事件：

- `DOMContentLoaded` - 浏览器已完全加载HTML，并且构建了DOM树，但是可能尚未加载图片`<img>`和样式表之类的外部资源。
- `load` - 不止完成了HTML的加载，其他外部资源也已经全部加载：图片，样式等等。
- `beforeunload/unload` - 用户离开页面。

每个事件都是非常有用的：

- `DOMContentLoaded`事件 - DOM树已经准备好了，因此处理程序可以查找DOM节点，初始化接口。
- `load`事件 - 外部资源已经加载完成，所以样式已经被应用，图谱的大小已知等等。
- `beforeunload`事件 - 用户已经离开页面：我们可以检查用户是否保存了一些修改并询问他们是否真的要离开页面。
- `unload` - 用户几乎离开了，但是我们仍然可以启动一些操作，例如发送统计信息。

让我们来探索这些事件的细节吧。

##### DOMContentLoaded

`DOMContentLoaded`事件发生在`document`对象上。

我们必须使用`addEventListener`去捕获它：

```javascript
document.addEventListener("DOMContentLoaded", ready);
// not "document.onDOMContentLoaded = ..."
```

看个例子：

```html
<script>
  function ready() {
    alert('DOM is ready');

    // image is not yet loaded (unless was cached), so the size is 0x0
    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);
  }

  document.addEventListener("DOMContentLoaded", ready);
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">
```

在这个例子中`DOMContenLoaded`的处理事件在文档被加载完成，所以这里看到所有元素，包括下面的`<img>`。

但是它没有等到图片加载完成。所以`alert`显示图片的`size`为0。

乍一看，`DOMContentLoaded`事件非常简单。DOM树已准备就绪 - 这就是事件。 虽然没有什么特别之处。

###### [DOMContentLoaded and scripts](https://javascript.info/onload-ondomcontentloaded#domcontentloaded-and-scripts)

当浏览器在处理一个HTML文档且遇到一个`<script>`标签的时候，它需要在继续构建DOM树前先执行该部分脚本。这是一种预防措施，因为脚本可能想修改DOM树，甚至使用`document.write`写入元素，所以`DOMContentLoaded`需要等待。

因此，`DOMContentLoaded`肯定在以下脚本之后发生：

```html
<script>
  document.addEventListener("DOMContentLoaded", () => {
    alert("DOM ready!");
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script>

<script>
  alert("Library loaded, inline script executed");
</script>
```

这上面这个例子中，我们将先看到"Library loaded..."，然后看到"DOM ready!"（此时所有脚本执行完成了）。

------

脚本不会阻塞`DOMContentLoaded`

上述规则有两个例外：

1. 稍后将[介绍](https://javascript.info/script-async-defer)具有`async`属性的脚本不会阻塞`DOMContentLoaded`。
2. 使用`document.createElement（'script'）`动态生成并随后添加到网页中的脚本也不会阻止此事件。

###### [DOMContentLoaded and styles](https://javascript.info/onload-ondomcontentloaded#domcontentloaded-and-styles)

外部样式表不会影响DOM树，所以`DOMContentLoaded`不需要等待它们的加载。

但是有一个陷阱。如果样式后面有脚本，则该脚本必须等到样式加载后再加载：

```html
<link type="text/css" rel="stylesheet" href="style.css">
<script>
  // the script doesn't not execute until the stylesheet is loaded
  alert(getComputedStyle(document.body).marginTop);
</script>
```

这样做的原因是脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。 自然它必须等待样式加载。

因此`DOMContentLoaded`要等待脚本，现在它必须也要等到样式加载。

###### [Built-in browser autofill](https://javascript.info/onload-ondomcontentloaded#built-in-browser-autofill)

Firefox，Chrome和Opera会在`DOMContentLoaded`上自动填充表单。

例如，如果页面的表单具有登录名和密码，并且浏览器记住了这些值，那么在`DOMContentLoaded`上，它可能会尝试自动填充它们（如果得到用户的认可）。

因此，如果`DOMContentLoaded`被长时间加载的脚本推迟，则自动填充也会等待。 您可能已经在某些网站上看到过（如果您使用浏览器自动填充）–登录名/密码字段不会立即自动填充，但是要等到页面完全加载才会有延迟。 这实际上是`DOMContentLoaded`事件的延迟。

##### [window.onload](https://javascript.info/onload-ondomcontentloaded#window-onload)

加载整个页面（包括样式，图像和其他资源）时，将触发`window`对象上的`load`事件。

下面的示例正确显示了图像大小，因为`window.onload`等待所有图像：

```html
<script>
  window.onload = function() {
    alert('Page loaded');

    // image is loaded at this time
    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);
  };
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">
```

##### [window.onunload](https://javascript.info/onload-ondomcontentloaded#window-onunload)

当访问者离开页面时，`unload`事件将在`window`上触发。 我们可以在那里进行一些不拖延的操作，例如关闭相关的弹出窗口。

值得注意的例外是发送分析。

假设我们收集有关页面使用方式的数据：鼠标单击，滚动，查看页面区域等。

自然，`unload`事件是用户离开我们的时候，我们希望将数据保存在我们的服务器上。

存在一种特殊的`navigator.sendBeacon（url，data）`方法来满足此类需求，在规范https://w3c.github.io/beacon/中进行了描述。

它在后台发送数据。 过渡到另一个页面没有延迟：浏览器离开页面，但仍执行`sendBeacon`。

这里展示了如何使用它：

```javascript
let analyticsData = { /* object with gathered data */ };

window.addEventListener("unload", function() {
  navigator.sendBeacon("/analytics", JSON.stringify(analyticsData));
};
```

- 该请求以POST的形式发送。
- 我们不仅可以发送字符串，还可以发送表格和其他格式（如[Fetch](https://javascript.info/fetch)一章中所述），但通常它是一个字符串对象。
- 数据限制为64kb。

`sendBeacon`请求完成后，浏览器可能已经离开了文档，因此无法获取服务器响应（对于分析而言通常为空）。

还有一个`keepalive`标志，用于在[fetch](https://javascript.info/fetch) 方法中针对通用网络请求执行此类“页面左移”请求。 您可以在[Fetch API](https://javascript.info/fetch-api)一章中找到更多信息。

如果我们要取消到另一个页面的转换，则无法在此处进行。 但是我们可以使用另一个事件 – `onbeforeunload`。

##### [window.onbeforeunload](https://javascript.info/onload-ondomcontentloaded#window.onbeforeunload)

如果访客启动了离开页面的导航或试图关闭窗口，则`beforeunload`处理程序会要求其他确认。

如果我们取消该事件，浏览器可能会询问访问者是否确定。

您可以通过运行以下代码然后重新加载页面来进行尝试：

```javascript
window.onbeforeunload = function() {
  return false;
};
```

由于历史原因，返回非空字符串也视为取消事件。 一段时间以前，使用过的浏览器将其显示为消息，但正如[现代规范](https://html.spec.whatwg.org/#unloading-documents)所说，它们不应该显示。

这是一个例子：

```javascript
window.onbeforeunload = function() {
  return "There are unsaved changes. Leave now?";
};
```

行为已更改，因为某些网站管理员通过显示误导性和令人讨厌的消息来滥用此事件处理程序。 因此，目前旧的浏览器仍可能将其显示为消息，但除此之外 – 无法自定义显示给用户的消息（现代浏览器都是不行滴）。

##### [readyState](https://javascript.info/onload-ondomcontentloaded#readystate)

如果在文档加载后设置`DOMContentLoaded`处理程序，会发生什么情况？

自然，它永远不会运行。

在某些情况下，我们不确定文档是否准备就绪。 我们希望函数在加载DOM时执行，无论是现在还是以后。

`document.readyState`属性告诉我们当前的加载状态。

有3种可能的值：

- `"loading"` – the document is loading.
- `"interactive"` – the document was fully read.
- `"complete"` – the document was fully read and all resources (like images) are loaded too.

因此，我们可以检查`document.readyState`并设置处理程序，或者在就绪后立即执行代码。

像这样：

```javascript
function work() { /*...*/ }

if (document.readyState == 'loading') {
  // loading yet, wait for the event
  document.addEventListener('DOMContentLoaded', work);
} else {
  // DOM is ready!
  work();
}
```

还有一个`readystatechange`事件会在状态更改时触发，因此我们可以像这样打印所有这些状态：

```javascript
// current state
console.log(document.readyState);

// print state changes
document.addEventListener('readystatechange', () => console.log(document.readyState));
```

`readystatechange`事件是很久以前出现的一种跟踪文档加载状态的替代方法。 如今，它很少使用。

让我们看看完整事件流的完整性。

这是包含`<iframe>`，`<img>`和记录事件的处理程序的文档：

```html
<script>
  log('initial readyState:' + document.readyState);

  document.addEventListener('readystatechange', () => log('readyState:' + document.readyState));
  document.addEventListener('DOMContentLoaded', () => log('DOMContentLoaded'));

  window.onload = () => log('window onload');
</script>

<iframe src="iframe.html" onload="log('iframe onload')"></iframe>

<img src="http://en.js.cx/clipart/train.gif" id="img">
<script>
  img.onload = () => log('img onload');
</script>
```

工作示例在[沙箱](https://plnkr.co/edit/K17sAQX6YDMfbN3J5HSH?p=preview)中。

典型输出：

1. [1] initial readyState:loading
2. [2] readyState:interactive
3. [2] DOMContentLoaded
4. [3] iframe onload
5. [4] img onload
6. [4] readyState:complete
7. [4] window onload

方括号中的数字表示发生时间的大概时间。 标有相同数字的事件大约在同一时间（±几毫秒）发生。

- `document.readyState`在`DOMContentLoaded`之前变为`interactive`。 这两件事实际上是相同的。
- 加载所有资源（`iframe`和`img`）后，`document.readyState`变为`complete`。 在这里，我们可以看到它与`img.onload`（`img`是最后一个资源）和`window.onload`大约同时发生。 切换到`complete`状态意味着与`window.onload`相同。 区别在于`window.onload`始终在所有其他`load`处理程序之后运行。

##### [总结](https://javascript.info/onload-ondomcontentloaded#summary)

页面加载事件：

- DOM准备就绪后，将在`document`上触发`DOMContentLoaded`事件。 我们可以在此阶段将JavaScript应用于元素。
  - `<script> ... </ script>`或`<script src =“ ...”> </ script>`之类的脚本阻止DOMContentLoaded，浏览器等待它们执行。
  - 图像和其他资源也可能仍继续加载。
- 加载页面和所有资源时，将触发`window`上的`load`事件。 我们很少使用它，因为通常无需等待那么长时间。
- 当用户想要离开页面时，`window`上的`beforeunload`事件触发。 如果我们取消活动，浏览器会询问用户是否真的要离开（例如，我们有未保存的更改）。
- 当用户最终离开时，将触发`window`上的`The unload`事件，在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。 由于该限制，很少使用。 我们可以使用`navigator.sendBeacon`发送网络请求。
- `document.readyState`是文档的当前状态，可以在`readystatechange`事件中跟踪更改：
  - `loading` – the document is loading.
  - `interactive` – the document is parsed, happens at about the same time as `DOMContentLoaded`, but before it.
  - `complete` – the document and resources are loaded, happens at about the same time as `window.onload`, but before it.

#### 5.2Script 标签属性：async, defer


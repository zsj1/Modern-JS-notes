

# 现代javascript教程

## 第1部分：JavaScript 编程语言

### 第四章、数据类型

#### 4.1基本类型的方法

JavaScript 允许我们像对象一样使用基本类型（字符串，数字等）。

基本类型还提供调用方法等。我们会尽快研究这些，但首先我们会看看它是如何工作的，毕竟基本类型不是对象（在这里我们会分析的更加清楚）。

我们来看看基本类型和对象之间的关键区别。

基本类型

- 是原始类型中的一种值。
- 在 JavaScript 中有 6 种基本类型：`string`、`number`、`boolean`、`symbol`、`null` 和 `undefined`。

对象类型

- 能够存储多个值作为属性。
- 可以使用大括号 `{}` 创建对象，例如：`{name: "John", age: 30}`。JavaScript 中还有其他种类的对象，例如函数就是对象。

关于对象的最好的事情之一是我们可以存储一个函数作为它的一个属性：

```javascript
let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
```

所以我们在这里创建了一个包含 `sayHi` 方法的对象 `john`。

许多内置对象已经存在，例如那些处理日期，错误，HTML 元素等的内置对象。它们具有不同的属性和方法。

但是，这些特性都是有成本的！

对象比基本类型“更重”。他们需要额外的资源来支持运作。但是，由于属性和方法在编程中非常有用，JavaScript 引擎会尝试优化它们以减少额外的负担。

##### [作为对象的基本类型](https://zh.javascript.info/primitives-methods#zuo-wei-dui-xiang-de-ji-ben-lei-xing)

以下是 JavaScript 创建者面临的悖论：

- 人们想对字符串或数字这样的基本类型做很多事情，要是能通过其方法完成就太好了。
- 基本类型必须尽可能的简单轻量。

而解决方案看起来多少有点尴尬，如下：

1. 基本类型仍然是原始数据。如预期相同，提供单个值
2. JavaScript 允许访问字符串，数字，布尔值和符号的方法和属性。
3. 当进行访问时，创建一个特殊的“包装对象”，它提供额外的功能，运行后即被销毁。

“包装对象”对于每种基本类型调用都是不同的，如`String`, `Number`, `Boolean` 和 `Symbol`。因此，他们提供了不同的方法。

例如，方法 [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) 返回一个大写的字符串。用法演示如下：

```javascript
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
```

很简单，对吧？以下是 `str.toUpperCase()` 实际发生的情况：

1. 字符串 `str` 是一个基本类型。所以在访问它的属性时，会即刻创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 `toUpperCase()`。
2. 该方法运行并返回一个新的字符串（由 `alert` 显示）。
3. 特殊对象被销毁，只留下基本类型 `str`。

所以基本类型可以提供方法，但它们依然是轻量级的。

JavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创造了一样。

数字有其自己的方法，例如，[toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 将数字四舍五入到给定的精度：

```javascript
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```

我们将在后面章节中看到更具体的方法 [数字类型](https://zh.javascript.info/number) 和 [字符串](https://zh.javascript.info/string)。

------

**构造函数 `String/Number/Boolean` 仅供内部使用**

像 Java 这样的一些语言允许我们使用 `new Number(1)` 或 `new Boolean(false)` 等语法明确地为基本类型创建“包装对象”。

在 JavaScript 中，由于历史原因，这也是可以的，但极其**不推荐**。因为这样会出问题。例如：

```javascript
alert( typeof 1 ); // "number"

alert( typeof new Number(1) ); // "object"!
```

同样的，`zero`，是一个对象，alert 将显示出来：

```javascript
let zero = new Number(0);

if (zero) { // zero is true, because it's an object
  alert( "zero is truthy?!?" );
}
```

另一方面，不使用 `new` 的 `String/Number/Boolean` 是一个明智的选择。它们将一个值转换为相应的类型：转成 string，number，或 boolean（原始类型）。

例如，下面完全是有效的：

```javascript
let num = Number("123"); // 将字符串转成数字
```

------

**null/undefined 没有任何方法**

特殊的基本类型 `null` 和 `undefined` 是个例外。他们没有相应的“包装对象”，也没有提供任何方法。从某种意义上说，他们是“最原始的”。尝试访问这种值的属性会导致错误：

```javascript
alert(null.test); // error
```

##### [总结](https://zh.javascript.info/primitives-methods#zong-jie)

- 除 `null` 和 `undefined` 以外的基本类型都提供了许多有用的方法。我们将在即将到来的章节中研究这些内容。
- 从形式上讲，这些方法通过临时对象工作，但 JavaScript 引擎可以很好地调整以优化内部，因此调用它们并不需要太高的成本。

#### 4.2数字类型

JavaScript 中的所有数字都以 64 位格式 [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985) 存储，也称为“双精度”。

让我们回顾一下并展开我们目前了解的内容。

##### [编写数字的更多方法](https://zh.javascript.info/number#bian-xie-shu-zi-de-geng-duo-fang-fa)

想象一下，我们需要写 10 亿。显而易见的方法是：

```javascript
let billion = 1000000000;
```

但在现实生活中，我们通常避免写一长串零，因为它很容易输入错误。另外，我们很懒。我们通常会为十亿或七十三亿写一些类似于 `1bn` 的数字，为 `7.3bn`。对于大多数人来说也是如此。

在 JavaScript 中，我们通过在数字后附加字母 “e” 来缩短数字，并指定零的数量来计数：

```javascript
let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

alert( 7.3e9 );  // 7.3 billions (7,300,000,000)
```

换句话说，`"e"` 把数字乘以 `1` 后面跟着指定数量的 0。

```javascript
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
```

现在让我们写一些非常小的东西。例如：1 微秒（百万分之一秒）：

```javascript
let ms = 0.000001;
```

就像以前一样，使用 `"e"` 可以提供帮助。如果我们想避免明确地写零，我们可以说：

```javascript
let ms = 1e-6; // six zeroes to the left from 1
```

如果我们计算 `0.000001` 中的零，则有 6 个。所以自然是 `1e-6`。

换句话说，`e` 后面的负数表示除以 1 后面跟着给定数量的 0：

```javascript
// -3 divides by 1 with 3 zeroes
1e-3 = 1 / 1000 (=0.001)

// -6 divides by 1 with 6 zeroes
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```

##### [十六进制，二进制和八进制数字](https://zh.javascript.info/number#shi-liu-jin-zhi-er-jin-zhi-he-ba-jin-zhi-shu-zi)

[十六进制](https://en.wikipedia.org/wiki/Hexadecimal)数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多事物。所以很自然地，写一个更简短的方法：`0x` 然后是数字。例如：

```javascript
alert( 0xff ); // 255
alert( 0xFF ); // 255 (the same, case doesn't matter)
```

虽然二进制和八进制数字系统很少使用，但也支持使用 `0b` 和 `0o` 前缀：

```javascript
let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides
```

只有这三种进制支持这种写法。对于其他进制，我们应该使用函数 `parseInt`（我们将在本章后面看到）。

##### [toString(base)](https://zh.javascript.info/number#tostringbase)

方法 `num.toString(base)` 返回带有给定 `base` 的进制中 `num` 的字符串表示。

举个例子：

```javascript
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base` 可以从 `2` 变到 `36`。默认情况下它是 `10`。

常见的用例如下：

- **base=16** 用于十六进制颜色，字符编码等，数字可以是 `0..9` 或 `A..F`。

- **base=2** 主要用于调试按位操作，数字可以是 `0` 或 `1`。

- **base=36** 是最大值，数字可以是 `0..9` 或 `A..Z`。整个拉丁字母用来表示一个数字。对于 `36` 来说，一个有趣而有用的例子是，当我们需要将一个较长的数字标识符变成较短的时候，例如做一个简短的URL。可以简单地用基数为 `36` 的数字系统表示：

  ```javascript
  alert( 123456..toString(36) ); // 2n9c
  ```

------

**调用方法的两个点**

请注意 `123456..toString(36)` 中的两个点不是拼写错误。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 `toString`，那么我们需要在它后面放置两个点 `..`。

如果我们放置一个点：`123456.toString(36)`，那么会出现错误，因为 JavaScript 语法暗示了第一个点之后的小数部分。如果我们再放一个点，那么 JavaScript 知道小数部分是空的，现在进入方法。

也可以写 `(123456).toString(36)`。

##### [数值修约（Rounding）](https://zh.javascript.info/number#shu-zhi-xiu-yue-rounding)

使用数字时最常用的操作之一是数值修约。

有几个内置的数值修约函数：

- `Math.floor`

  向下舍入：`3.1` 变成 `3`，`-1.1` 变成 `-2`。

- `Math.ceil`

  向上舍入：`3.1` 变成 `4`，`-1.1` 变成 `-1`。

- `Math.round`

  向最近的整数舍入：`3.1` 变成 `3`, 3.6`变成`4`，`-1.1`变成`-1`。

- `Math.trunc`（IE 浏览器不支持这个方法）

  删除小数点后的所有内容而不舍入：`3.1` 变成 `3`，`-1.1` 变成 `-1`。

以下是总结它们之间差异的表格：

|        | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
| :----- | :----------- | :---------- | :----------- | :----------- |
| `3.1`  | `3`          | `4`         | `3`          | `3`          |
| `3.6`  | `3`          | `4`         | `4`          | `3`          |
| `-1.1` | `-2`         | `-1`        | `-1`         | `-1`         |
| `-1.6` | `-2`         | `-1`        | `-2`         | `-1`         |

这些函数涵盖处理数字小数部分的所有可能方法。但是如果我们想在十进制后将数字四舍五入到 `n` 位呢？

例如，我们有 `1.2345`，并且想把它舍入到 2 位数，只得到 `1.23`。

有两种方法可以这样做：

1. 乘法和除法

   例如，要将数字四舍五入到小数点后的第二个数字，我们可以将数字乘以 100，调用舍入函数，然后再将其除回 100。

   ```javascript
   let num = 1.23456;
   
   alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
   ```

2. 函数 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 将点数后的数字四舍五入到 `n` 个数字并返回结果的字符串表示。

   ```javascript
   let num = 12.34;
   alert( num.toFixed(1) ); // "12.3"
   ```

   这会向上或向下舍入到最接近的值，类似于 `Math.round`：

   ```javascript
   let num = 12.36;
   alert( num.toFixed(1) ); // "12.4"
   ```

   请注意 `toFixed` 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零：

   

   ```javascript
   let num = 12.34;
   alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits
   ```

   我们可以使用一元加号或 `Number()` 调用将其转换为数字：`+ num.toFixed(5)`。

##### [不精确计算](https://zh.javascript.info/number#bu-jing-que-ji-suan)

在 js 内部，一个数字以 64 位格式 [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985) 表示，所以正好有 64 位可以存储一个数字：其中 52 个被使用存储这些数字，其中 11 个存储小数点的位置（它们对于整数为零），1 位用于符号。

如果一个数字太大，它会溢出 64 位存储，可能会输出无穷大：

```javascript
alert( 1e500 ); // Infinity
```

可能不那么明显，但经常会发生精度的损失。

考虑下这个（falsy！）测试：

```javascript
 alert( 0.1 + 0.2 == 0.3 ); // false
```

没错，如果我们检查 `0.1` 和 `0.2` 的总和是否为 `0.3`，们会得到 `false`。

奇怪！那么如果不是 `0.3`，那么又是什么呢？

```javascript
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

哎哟!这里的错误有更大的误差。想象一下，你正在制作一个电子购物网站，访问者将 `0.10 美元` 和 `0.20 美元` 商品放入他的图表中。订单总额将是 `$ 0.30000000000000004`。这会让任何人感到惊讶。

但为什么会发生这样的事呢？

一个数字以二进制形式存储在内存中，一个 1 和 0 的序列。但是像十进制数字系统看起来很简单的 `0.1`，`0.2`这样的小数实际上是二进制形式的循环小数。

换句话说，什么是 `0.1`？`0.1` 就是把 1 除以 10 `1/10`，即十分之一。在十进制数字系统中，这些数字很容易表示。将它比作三分之一：`1/3`。它变成了循环小数 `0.33333(3)`。

所以，按这种用 `10` 划分可以保证在十进制系统中运行良好，但用 `3` 划分不是。出于同样的原因，在二进制数字系统中，`2` 的幂的分割保证工作，但 `1/10` 变成一个无限的二进制小数。

使用二进制系统只能存储 *0.1* 或 *0.2*，就像没有办法将三分之一存储为小数部分一样。

数字格式 IEEE-754 通过四舍五入到最接近的可能数字来解决此问题。这些舍入规则通常不允许我们看到 `极小的精确度损失`，因此数字显示为 `0.3`。但要小心，损失依然存在。

我们可以看到这一点：

```javascript
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

当我们给两个数字求和时，他们的“精度损失”会加起来。

这就是为什么 `0.1 + 0.2` 不等于 `0.3` 的原因。

我们能解决这个问题吗？当然，有很多方法：

1. 我们可以在特定函数的帮助下对结果进行四舍五入 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)：

   ```javascript
   let sum = 0.1 + 0.2;
   alert( sum.toFixed(2) ); // 0.30
   ```

   请注意 `toFixed` 总是返回一个字符串。它确保它在小数点后有 2 位数字。如果我们有电子购物并需要显示 `0.30 美元`，这实际上很方便。对于其他情况，我们可以使用一元加号将它强制为一个数字：

   ```javascript
   let sum = 0.1 + 0.2;
   alert( +sum.toFixed(2) ); // 0.3
   ```

2. 我们可以暂时将数字转换为数学整数，然后将其恢复。它是这样工作的：

   ```javascript
   alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
   ```

   这是有效的，因为当我们做 `0.1 * 10 = 1` 和 `0.2 * 10 = 2` 时，那么这两个数字就变成了整数，并且没有精度损失。**这个方法很6，有助于深刻理解原因。**

3. 如果我们在与一家商店打交道，那么最激进的解决方案就是将所有价格存储在美分中，并且根本不使用分数。但是，如果我们应用 30％ 的折扣呢？在实践中，完全回避分数是很难实现的，所以上述解决方案有助于避免这种缺陷。

------

**有趣的事情**

尝试运行这个：

```javascript
// Hello! I'm a self-increasing number!
alert( 9999999999999999 ); // shows 10000000000000000
```

出现了同样的问题：精度的损失。该号码有 64 位，其中 52 位可用于存储数字，但这还不够。所以最不重要的数字就消失了。

JavaScript 在这种事件中不会触发错误。它尽最大努力使数字符合所需的格式，但不幸的是，这种格式不够大到满足需求。

------

**两个零**

数字内部表示的另一个有趣结果是存在两个零：`0` 和 `-0`。

这是因为一个符号由一个位表示，所以每个数字可以是正数或负数，包括零。

在大多数情况下，这种区别并不明显，因为操作员可以将它们视为相同。

##### [测试：isFinite 和 isNaN](https://zh.javascript.info/number#ce-shi-isfinite-he-isnan)

还记得这两个特殊的数值吗？

- `Infinity`（和 `-Infinity`）是一个特殊的数值，比任何数值都大（小）。
- `NaN` 代表一个错误。

它们属于 `数字` 类型，但不是 `普通` 数字，因此有特殊函数可以检查它们：

- `isNaN(value)` 将其参数转换为数字，然后测试它是否为 `NaN`：

  ```javascript
  alert( isNaN(NaN) ); // true
  alert( isNaN("str") ); // true
  ```

  但是我们需要这个功能吗？我们不能只使用比较 `=== NaN` 吗？对不起，但答案是否定的。值 “NaN” 是独一无二的，它不等于任何东西，包括它本身：

  ```javascript
  alert( NaN === NaN ); // false
  ```

- `isFinite(value)` 将其参数转换为数字，如果是常规数字，则返回 `true`，而不是 `NaN / Infinity / -Infinity`：

  ```javascript
  alert( isFinite("15") ); // true
  alert( isFinite("str") ); // false, because a special value: NaN
  alert( isFinite(Infinity) ); // false, because a special value: Infinity
  ```

有时 `isFinite` 用于验证字符串值是否为常规数字：

```javascript
let num = +prompt("Enter a number", '');

// 结果会是 true，除非你输入无穷大，无穷大或不是数字
alert( isFinite(num) );
```

**请注意，所有数字函数（包括 `isFinite`）中的空字符串或空格字符串均被视为 `0`。*Important!!!***

------

**与 Object.is 进行比较**

有一种特殊的内置方法 [Object.is](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/is)，它可以比较 `===` 等值，但对于两种边缘情况更可靠：

1. 它适用于 `NaN`： `Object.is（NaN，NaN）=== true`，这是件好事。
2. 值 `0` 和 `-0` 是不同的：`Object.is（0，-0）=== false`，它不是很重要，但这些值在技术上是不同的。

在所有其他情况下，`Object.is(a，b)` 与 `a === b` 相同。

这种比较方式经常用于 JavaScript 规范。当内部算法需要比较两个值完全相同时，它使用 Object.is（内部称为 [同值相等（SameValue）](https://tc39.github.io/ecma262/#sec-samevalue)）。

##### [parseInt 和 parseFloat](https://zh.javascript.info/number#parseint-he-parsefloat)

**以前都没注意，这个是从头开始往后读，下面的例子好精彩。**

使用加号 `+` 或 `Number()` 的数字转换是严格的。如果一个值不完全是一个数字，就会失败：

```javascript
alert( +"100px" ); // NaN
```

唯一的例外是字符串开头或结尾的空格，因为它们会被忽略。

但在现实生活中，我们经常以单位表示值，比如 CSS 中的 `"100px"` 或 `"12pt"`。在许多国家，货币符号也超过了金额，所以我们有 `"19€"`，并希望从中提取一个数值。

这就是 `parseInt` 和 `parseFloat` 的作用。

他们从字符串中“读出”一个数字，直到他们可以。如果发生错误，则返回收集的数字。函数 `parseInt` 返回一个整数，而 `parseFloat` 将返回一个浮点数：

```javascript
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, only the integer part is returned
alert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading
```

有时候 `parseInt / parseFloat` 会返回 `NaN`。一般发生在没有数字可读的情况下：

```javascript
alert( parseInt('a123') ); // NaN, the first symbol stops the process
```

------

**parseInt(str, radix)的第二个参数**

`parseInt()` 函数有一个可选的第二个参数。它指定了数字系统的基础，因此 `parseInt` 还可以解析十六进制数字，二进制数字等字符串：

```javascript
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, without 0x also works

alert( parseInt('2n9c', 36) ); // 123456
```

##### [其他数学函数](https://zh.javascript.info/number#qi-ta-shu-xue-han-shu)

JavaScript 有一个内置的 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象，它包含了一个小型的数学函数和常量库。

几个例子：

- `Math.random()`

  返回从 0 到 1 的随机数（不包括 1）

  ```javascript
  alert( Math.random() ); // 0.1234567894322
  alert( Math.random() ); // 0.5435252343232
  alert( Math.random() ); // ... (any random numbers)
  ```

- `Math.max(a, b, c...)` / `Math.min(a, b, c...)`

  从任意数量的参数中返回最大/最小值。

  ```javascript
  alert( Math.max(3, 5, -10, 0, 1) ); // 5
  alert( Math.min(1, 2) ); // 1
  ```

- `Math.pow(n, power)`

  返回 n 的 power 次幂，即 n^power。

  ```javascript
  alert( Math.pow(2, 10) ); // 2 的 10 次幂 = 1024
  ```

这里有 `Math` 对象中的更多函数和常量，包括三角函数，你可以在这里找到它 [docs for the Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math)。

##### [总结](https://zh.javascript.info/number#zong-jie)

写非常大的数字：

- 附加 `"e"` 来省略 0，e 后面的数字就是零的个数。就像：`123e6` 是 `123` 后面接 6 个零。
- `"e"` 后面的负数将导致数字除以 1 后面接着给定数量的零。e-6 那是一百万分之一。

对于不同的进制：

- 可以在十六进制（`0x`），八进制（`0o`）和二进制（`0b`）系统中直接写入数字。
- `parseInt(str，base)` 解析来自任何数字系统的整数，其基数为：`2≤base≤36`。
- `num.toString(base)` 将数字转换为数字系统中具有给定 `base` 的字符串。

将 `12pt` 和 `100px` 等值转换为数字：

- 使用 `parseInt / parseFloat` 进行 `软` 转换，它从字符串中读取一个数字，然后返回错误发生前可以读取的值。

分数：

- 使用 `Math.floor`，`Math.ceil`，`Math.trunc`，`Math.round` 或 `num.toFixed(precision)` 循环。
- 请记住，使用分数时会损失精度。

更多的数学函数：

- 需要时请参阅 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象,虽然这个文档非常小,但是它可以满足基础的要求。

##### BigInt

其实已经新出了一个类型BigInt，解决了之前的好多问题，[详情链接](https://segmentfault.com/a/1190000019912017)。

#### 4.3字符串

在 JavaScript 中，文本数据被作为字符串存储，字符没有单独的类型。

字符串的内部格式总是 [UTF-16](https://en.wikipedia.org/wiki/UTF-16)，它不会绑定到页面编码中。

##### [引号（Quotes）](https://zh.javascript.info/string#yin-hao-quotes)

让我们回忆一下这些引号。

字符串可以包含在单引号、双引号或反引号中：

```javascript
let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
```

单引号和双引号本质上是一样的。但是，反引号允许我们通过 `${…}` 将任何表达式嵌入到字符串中：

```javascript
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
```

使用反引号的另一个优点是它们允许字符串跨行：

```javascript
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // 客人清单，多行
```

看起来很自然，不是吗？但是单引号和双引号可不能这样做。

如果我们使用单引号或双引号来实现字符串跨行的话，则会出现错误：

```javascript
let guestList = "Guests: // Error: Unexpected token ILLEGAL
  * John";
```

当不考虑多行字符串的需要时，单引号和双引号来自语言创建的古时代。反引号出现较晚，因此更通用。

反引号还允许我们在第一个反引号之前指定一个“模版函数”。语法是：`func`string``。函数 `func` 被自动调用，接收字符串和嵌入式表达式，并处理它们。你可以在 [docs](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals) 中阅读更多关于它们的信息。这叫做 “tagged templates”。此功能可以更轻松地将字符串包装到自定义模版或其他函数中，但这很少使用。

##### [特殊字符](https://zh.javascript.info/string#te-shu-zi-fu)

我们仍然可以通过名为“换行符（newline character）”的方式用单引号和双引号来创建跨行字符串，其符号被写作 `\n`，用来表示换行：

```javascript
let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // 多行 guests
```

例如，这两行描述相同，只是书写方式不同：

```javascript
let str1 = "Hello\nWorld"; // 使用“换行符”创建的两行字符串

// 使用普通换行符和反引号创建的两行
let str2 = `Hello
World`;

alert(str1 == str2); // true
```

还有其他不常见的“特殊字符”。

这是其完整列表：

| 字符                                    | 描述                                                         |
| :-------------------------------------- | :----------------------------------------------------------- |
| `\n`                                    | 换行                                                         |
| `\r`                                    | 回车：不单独使用。Windows 文本文件使用两个字符 `\r\n` 的组合来表示换行符。 |
| `\'`, `\"`                              | 引号                                                         |
| `\\`                                    | 反斜线                                                       |
| `\t`                                    | 制表符                                                       |
| `\b`, `\f`, `\v`                        | 退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了         |
| `\xXX`                                  | 具有给定十六进制的 unicode `XX`，例如：`'\x7A'` 和 `'z'` 相同。 |
| `\uXXXX`                                | 带有 UTF-16 编码的十六进制代码 `XXXX` 的 unicode 符号，例如 `\u00A9` —— 是版权符号 `©` 的 unicode。它必须是 4 个十六进制数字。 |
| `\u{X…XXXXXX}`（1 到 6 个十六进制字符） | 具有给定 UTF-32 编码的 unicode 符号。一些罕见的字符用两个 unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。 |

unicode 示例：

```javascript
alert( "\u00A9" ); // ©
alert( "\u{20331}" ); // 佫，罕见的中国象形文字（长 unicode）
alert( "\u{1F60D}" ); // 😍，笑脸符号（另一个长 unicode）
```

所有的特殊字符都以反斜杠字符 `\` 开始。它也被称为“转义字符”。

如果我们想要在字符串中插入一个引号，我们也会使用它。例如：

```javascript
alert( 'I\'m the Walrus!' ); // I'm the Walrus!
```

正如你所看到的，我们必须用反斜杠 `\'` 来预设值内部引号，否则就表示字符串结束。

当然，只有与外部闭合引号相同的引号才需要转义。因此，作为一个更优雅的解决方案，我们可以改用双引号或者反引号：

```javascript
alert( `I'm the Walrus!` ); // I'm the Walrus!
```

注意反斜杠 `\` 在 JavaScript 中用于正确读取字符串，然后消失。内存中的字符串没有 `\`。从上述示例中的 `alert` 可以清楚地看到 。

但是如果我们需要在字符串中显示一个实际的反斜杠 `\` 应该怎么做？

我们可以这样做，只需要将其书写两次 `\\`：

```javascript
alert( `The backslash: \\` ); // The backslash: \
```

##### [字符串长度](https://zh.javascript.info/string#zi-fu-chuan-chang-du)

`length` 属性有字符串长度：

```javascript
alert( `My\n`.length ); // 3
```

注意 `\n` 是一个单独的“特殊”字符，所以长度确实是 `3`

------

**`length` 是一个属性**

掌握其他语言的人，有时会错误地调用 `str.length()` 而不是 `str.length`。这是行不通的。

请注意 `str.length` 是一个数字属性，而不是函数。之后不需要添加括号。

##### [访问字符](https://zh.javascript.info/string#fang-wen-zi-fu)

在 `pos` 位置获取一个字符，可以使用方括号 `[pos]` 或者调用 [str.charAt(pos)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/charAt) 方法。第一个字符从零位置开始：

```javascript
let str = `Hello`;

// 第一个字符
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// 最后一个字符
alert( str[str.length - 1] ); // o
```

方括号是获取字符的一种现代化方法，而 `charAt` 是历史原因才存在的。

它们之间的唯一区别是，如果没有找到字符，`[]` 返回 `undefined`，而 `charAt` 返回一个空字符串：

```javascript
let str = `Hello`;

alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' （空字符串）
```

我们也可以使用 `for..of` 遍历字符：

```javascript
for (let char of "Hello") {
  alert(char); // H,e,l,l,o （char 变为“H”，然后是“e”，然后是“l”等）
}
```

##### [字符串不可变](https://zh.javascript.info/string#zi-fu-chuan-bu-ke-bian)

在 JavaScript 中，字符串不可更改。改变字符是不可能的。

我们证明一下为什么不可能：

```javascript
let str = 'Hi';

str[0] = 'h'; // error
alert( str[0] ); // 无法运行
```

通常的解决方法是创建一个新的字符串，并将其分配给 `str` 而不是以前的字符串。

例如：

```javascript
let str = 'Hi';

str = 'h' + str[1];  // 字符串替换

alert( str ); // hi
```

下面的文章，我们将看到更多的示例。

##### [改变大小写](https://zh.javascript.info/string#gai-bian-da-xiao-xie)

[toLowerCase()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase) 和 [toUpperCase()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) 可以改变大小写：

```javascript
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
```

或者我们想要一个小写字符：

```javascript
alert( 'Interface'[0].toLowerCase() ); // 'i'
```

##### [查找子字符串](https://zh.javascript.info/string#cha-zhao-zi-zi-fu-chuan)

在字符串中查找子字符串有很多种方法。

###### [str.indexOf](https://zh.javascript.info/string#strindexof)

第一个方法是 [str.indexOf(substr, pos)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)。

它从给定位置 `pos` 开始，在 `str` 中查找 `substr`，如果没有找到，则返回 `-1`，否则返回匹配成功的位置。

例如：

```javascript
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0，因为 'Widget' 一开始就被找到
alert( str.indexOf('widget') ); // -1，没有找到，检索是大小写敏感的

alert( str.indexOf("id") ); // 1，"id" 在位置 1 处（……idget 和 id）
```

可选的第二个参数允许我们从给定的起始位置开始检索

例如，`"id"` 第一次出现的位置是 `1`。查询下一个存在位置时，我们从 `2` 开始检索：

```javascript
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
```

如果我们对所有存在位置都感兴趣，可以在一个循环中使用 `indexOf`。每一次新的调用都发生在上一匹配位置之后：

```javascript
let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // 让我们查看一下

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Found at ${foundPos}` );
  pos = foundPos + 1; // 继续从下一个位置查找
}
```

相同的算法可以简写：

```javascript
let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
```

------

**`str.lastIndexOf(subStr, pos)`**

还有一个类似的方法 [str.lastIndexOf(subStr, pos)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf)，他从字符串的末尾开始搜索。

它会以相反的顺序列出事件。

------

在 `if` 测试中 `indexOf` 有一点不方便。我们不可以把它放在这样的 `if` 中：

```javascript
let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("We found it"); // doesn't work!
}
```

上述示例中的 `alert` 不会显示，因为 `str.indexOf("Widget")` 返回 `0`（意思是它在起始位置查找匹配）。是的，但是 `if` 认为 `0` 应该是 `false`。

因此我们实际上是从 `-1` 开始的，就像这样：

```javascript
let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("We found it"); // 现在运行了！
}
```

###### [按位（bitwise）NOT 技巧](https://zh.javascript.info/string#an-wei-bitwisenot-ji-qiao)

这里使用的一个老技巧是 [bitwise NOT](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT) `~` 运算符。它将该数字转换为 32-bit 整数（如果存在，则删除小数部分），然后反转其二进制表示中的所有位。

在实际使用中这表示对于 32-bit 整数 `~n` 的意思与 `-(n+1)` 完全一样。

例如：

```javascript
alert( ~2 ); // -3，和 -(2+1) 相同
alert( ~1 ); // -2，和 -(1+1) 相同
alert( ~0 ); // -1，和 -(0+1) 相同
alert( ~-1 ); // 0，和 -(-1+1) 相同
```

正如我们看到这样，只有当 `n == -1` 时，`~n` 才为零（that’s for any 32-bit signed integer `n`）。

因此，测试 `if ( ~str.indexOf("...") )` 为真仅当 `indexOf` 的结果不是 `-1`。换句话说，当有匹配时。

人们用它来简写 `indexOf` 检查：

```javascript
let str = "Widget";

if (~str.indexOf("Widget")) {
  alert( 'Found it!' ); // 正常运行
}
```

通常不建议以非显而易见的方式使用语言特性，但这种特殊技巧在旧代码中仍被广泛使用，所以我们应该理解它。

只要记住：`if (~str.indexOf(...))` 读作 “if found”。

确切地说，由于 `~` 运算符将大数字截断为 32 位，因此存在给出 `0` 的其他数字，最小的数字是 `~4294967295=0`。这使得这种检查只有在字符串不长的情况下才是正确的。

现在我们可以只能在旧的代码中看到这个技巧，因为现代 JavaScript 提供了 `.includes` 方法（见下文）。

###### [includes, startsWith, endsWith](https://zh.javascript.info/string#includesstartswithendswith)

更现代的方法 [str.includes(substr, pos)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/includes) 取决于 `str` 是否包含 `substr` 来返回 `true/false`。

如果我们需要测试匹配，这是正确的选择，但不需要它的位置：

```javascript
alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
```

`str.includes` 的第二个可选参数从以下位置开始搜索位置：

```javascript
alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, 位置 3 没有“id”
```

方法 [str.startsWith](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) 和 [str.endsWith](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) 完全按照它们所说的执行：

```javascript
alert( "Widget".startsWith("Wid") ); // true，“Widget”以“Wid”开始
alert( "Widget".endsWith("get") ); // true，“Widget”以“get”结束
```

###### [获取子字符串](https://zh.javascript.info/string#huo-qu-zi-zi-fu-chuan)

JavaScript 中有三种获取字符串的方法：`substring`、`substr` 和 `slice`。

`str.slice(start [, end])`

返回从 `start` 到（但不包括）`end` 的字符串部分。例如：

```javascript
let str = "stringify";
alert( str.slice(0, 5) ); // 'strin', 从 0 到 5 的子字符串（不包括 5）
alert( str.slice(0, 1) ); // 's', 从 0 到 1，但不包括 1，所以只有在 0 的字符
```

如果没有第二个参数，`slice` 运行到字符串末尾：

```javascript
let str = "stringify";
alert( str.slice(2) ); // 从第二个位置直到结束
```

`start/end` 也有可能是负值。它们的意思是位置从字符串结尾计算：

```javascript
let str = "stringify";

// 从右边的第四个位置开始，在右边的第一个位置结束
alert( str.slice(-4, -1) ); // */!
```

`str.substring(start [, end])`

返回 `start` 和 `end` **之间**的字符串部分。

这与 `slice` 几乎相同，但它允许 `start` 大于 `end`。

例如：

```javascript
let str = "stringify";

// 这些对于子串是相同的
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// ……但除了 slice：
alert( str.slice(2, 6) ); // "ring"（相同字符串）
alert( str.slice(6, 2) ); // ""（空字符串）
```

不支持负参数（不像 slice），它们被视为 `0`。

`str.substr(start [, length])`

从 `start` 开始返回给定 `length` 的字符串部分。

与以前的方法相比，这个允许我们指定 `length` 而不是结束位置：

```javascript
let str = "stringify";
alert( str.substr(2, 4) ); // 环，从第二位获得 4 个字符
```

第一个参数可能是负数，从结尾算起：

```javascript
let str = "stringify";
alert( str.substr(-4, 2) ); // gi，从第 4 位获得 2 个字符
```

我们回顾一下这些方法，以免混淆：

| 方法                    | 选择方式……                                | 负号参数            |
| :---------------------- | :---------------------------------------- | :------------------ |
| `slice(start, end)`     | 从 `start` 到 `end` (不含 `end`)          | 允许                |
| `substring(start, end)` | `start` 与 `end` 之间                     | 负值代表 `0`        |
| `substr(start, length)` | 从 `start` 开始获取长为 `length` 的字符串 | 允许 `start` 为负数 |

------

**使用哪一个？**

他们可以完成这项工作，形式上，`substr` 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中，它涵盖了主要由于历史原因而存在的浏览器特性。因此，非浏览器环境可能无法支持它。但实际上它在任何地方都有效。

相较于其他两个变体，`slice` 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 `slice` 就足够了。

##### [比较字符串](https://zh.javascript.info/string#bi-jiao-zi-fu-chuan)

正如我们从 [值的比较](https://zh.javascript.info/comparison) 一章中了解到的，字符串按字母顺序逐字比较。

不过，也有一些奇怪的地方。

1. 小写字母总是大于大写字母：

   ```javascript
   alert( 'a' > 'Z' ); // true
   ```

2. 带有指示性标记的字母“不正常”：

   ```javascript
   alert( 'Österreich' > 'Zealand' ); // true
   ```

   如果我们对这些国名进行排序，可能会导致奇怪的结果。通常，人们会期望 `Zealand` 在名单中的 `Österreich` 之后出现。

为了明白发生了什么，我们回顾一下在 JavaScript 中字符串的内部表示。

所有的字符串都使用 [UTF-16](https://en.wikipedia.org/wiki/UTF-16) 编码。即：每个字符都有相应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。

`str.codePointAt(pos)`

返回在 `pos` 位置的字符代码 :

```javascript
// 不同的字母有不同的代码
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
```

`String.fromCodePoint(code)`

通过数字 `code` 创建字符`alert( String.fromCodePoint(90) ); // Z`我们还可以用 `\u` 后跟十六进制代码，通过这些代码添加 unicode 字符：`// 在十六进制系统中 90 为 5a alert( '\u005a' ); // Z`

现在我们看一下代码 `65..220` 的字符（拉丁字母和一些额外的字符），方法是创建一个字符串：

```javascript
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```

看到没？先是大写字符，然后是一些特殊字符，然后是小写字符，而 `Ö` 几乎是最后输出。

现在很明显为什么 `a > Z`。

字符通过数字代码进行比较。越大的代码意味着字符越大。`a`（97）的代码大于 `Z`（90）。

- 所有小写字母都大于大写字母，因为它们的代码更大。
- 一些想 `Ö` 的字母与主要字母表不同。这里的代码比从 `a` 到 `z` 的代码都要大。

##### [正确的比较](https://zh.javascript.info/string#zheng-que-de-bi-jiao)

执行字符串比较的“正确”算法比看起来更复杂，因为不同语言的字母都不相同。

因此浏览器需要知道要比较的语言。

幸运地是，所有现代浏览器（IE-10 都需要额外的库 [Intl.JS](https://github.com/andyearnshaw/Intl.js/)) 支持国际化标准 [ECMA 402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)。

它提供了一种特殊的方法来比较不同语言的字符串，遵循它们的规则。

调用 [str.localeCompare(str2)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare) 会根据语言规则返回一个整数，这个整数能表明 `str` 是否在 `str2` 前，后或者等于它：

- 如果 `str` 小于 `str2` 返回负数，例如，`str` 在 `str2` 前。
- 如果 `str` 大于 `str2` 返回正数，例如，`str` 在 `str2` 后。
- 如果它们相等则返回 `0`。

例如：

```javascript
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```

这个方法实际上在[文档](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)中指定了两个额外的参数，它允许它指定语言（默认从环境中获取，字符顺序视语言不同而不同）并设置诸如区别大小之类的附加规则，或应该处理将 `"a"` 和 `"á"` 看作相等情况等。

##### [内部，Unicode](https://zh.javascript.info/string#nei-bu-unicode)

**高级内容**

这部分内容有需求请步入网址查看。

这部分会深入字符串内部。如果你计划处理表情符号、罕见的象形文字字符或其他罕见符号，这些知识会对你有用。

如果你不打算支持它们，你可以跳过这一部分。

##### [总结](https://zh.javascript.info/string#zong-jie)

- 有 3 种类型的引号。反引号允许字符串跨越多行并可以在 `${…}` 中嵌入表达式。
- JavaScript 中的字符串使用 UTF-16 进行编码。
- 我们可以使用像 `\n` 这样的特殊字符或通过使用 `\u...` 来操作它们的 unicode 进行字符插入。
- 获取字符时，使用 `[]`。
- 获取子字符串，使用 `slice` 或 `substring`。
- 字符串的大/小写转换，使用：`toLowerCase/toUpperCase`。
- 查找子字符串时，使用 `indexOf` 或 `includes/startsWith/endsWith` 进行简单检查。
- 根据语言比较字符串时使用 `localeCompare`，否则将按字符代码进行比较。

字符串还有其他几种有用的方法：

- `str.trim()` —— 删除字符串前后的空格 (“trims”)。
- `str.repeat(n)` —— 重复字符串 `n` 次。
- ……更多内容细节参见[手册](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String)。

字符串还具有用正则表达式执行搜索/替换的方法。但这个话题很大，因此我们单独将它放在 [正则表达式](https://zh.javascript.info/regular-expressions) 章节讨论。

#### 4.4数组

对象允许存储键值化的集合，这很好。

但很多时候我们需要的是**有序集合**，里面的元素都是按顺序排列的。例如，我们可能需要存储一些列表，比如用户、商品以及 HTML 元素等。

这里使用对象就不是很方便了，因为对象不提供能够管理元素顺序的方法。我们不能在已有的元素“之间”插入一个新的属性。这种场景下对象就不太适用了。

这时一个特殊的数据结构数组（`Array`）就派上用场了，它能存储有序的集合。

##### [声明](https://zh.javascript.info/array#sheng-ming)

创建一个空数组有两种语法：

```javascript
let arr = new Array();
let arr = [];
```

绝大多数情况下使用的都是第二种语法。我们可以在方括号中添加初始元素：

```javascript
let fruits = ["Apple", "Orange", "Plum"];
```

数组元素从 0 开始编号。

我们可以将元素的索引值填写在方括号内来获取元素：

```javascript
let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum
```

可以替换元素：

```javascript
fruits[2] = 'Pear'; // 现在变成 ["Apple", "Orange", "Pear"]
```

…或者新加一个元素：

```javascript
fruits[3] = 'Lemon'; // 现在变成 ["Apple", "Orange", "Pear", "Lemon"]
```

`length` 属性的值是数组中元素的总个数

```javascript
let fruits = ["Apple", "Orange", "Plum"];

alert( fruits.length ); // 3
```

也可以用 `alert` 来显示整个数组。

```javascript
let fruits = ["Apple", "Orange", "Plum"];

alert( fruits ); // Apple,Orange,Plum
```

数组可以存储任何类型的元素。

例如:

```javascript
// 混合值
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// 获取索引为 1 的对象然后显示它的 name
alert( arr[1].name ); // John

// 获取索引为 3 的函数并执行
arr[3](); // hello
```

##### [pop/push, shift/unshift 方法](https://zh.javascript.info/array#poppushshiftunshift-fang-fa)

[队列](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))是最常见的使用数组的方法之一. 在计算机科学中，这意味着一个有序的元素的集合支持两个操作：

- `push` 在末端添加一个元素.
- `shift` 取出队列最前端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一。

这两种操作数组都支持.

队列的应用在实践中经常会碰到，例如需要在屏幕上显示消息队列。

数组还有另一个用例，就是数据结构[栈](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))。

它支持两种操作：

- `push` 在末端添加一个元素.
- `pop` 从末端取出一个元素.

所以新元素的添加和取出都是从“末端”开始的。

JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许从前端/末端来添加/删除元素。

这在计算机科学中叫做[双端队列](https://en.wikipedia.org/wiki/Double-ended_queue)。

**作用于数组末端的方法：**

`pop`

取出并返回数组的最后一个元素：

```javascript
let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.pop() ); // 移除 "Pear" 然后 alert 显示出来

alert( fruits ); // Apple, Orange
```

`push`

在数组末端添加元素：

```javascript
let fruits = ["Apple", "Orange"];

fruits.push("Pear");

alert( fruits ); // Apple, Orange, Pear
```

调用 `fruits.push(...)` 与 `fruits[fruits.length] = ...` 是一样的。

**作用于数组前端的方法：**

`shift`

取出数组的第一个元素并返回它：

```javascript
let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.shift() ); // 移除 Apple 然后 alert 显示出来

alert( fruits ); // Orange, Pear
```

`unshift`

在数组的前端添加元素：

```javascript
let fruits = ["Orange", "Pear"];

fruits.unshift('Apple');

alert( fruits ); // Apple, Orange, Pear
```

`push` 和 `unshift` 可以一次添加多个元素：

```javascript
let fruits = ["Apple"];

fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );
```

##### [内部](https://zh.javascript.info/array#nei-bu)

数组是一种特殊的对象。使用方括号来访问属性 `arr[0]` 实际上是来自于对象的语法。这个数字被用作键值。

他们扩展了对象，提供了特殊的方法来处理有序的数据集合，还添加了 `length` 属性。但是核心还是一个对象。

记住，在 JavaScript 中只有 7 种基本类型。数组是一个对象因此其行为也像一个对象。

例如，它是通过引用来复制的：

```javascript
let fruits = ["Banana"]

let arr = fruits; // 通过引用复制 (两个变量引用的是相同的数组)

alert( arr === fruits ); // true

arr.push("Pear"); // 通过引用修改数组

alert( fruits ); // Banana, Pear — 现在有 2 项了
```

…但是数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。

但是如果我们放弃以“有序集合”的方式使用数组，而是像一个常规对象一样使用它，这些就都不生效了。

例如可以这样做:

```javascript
let fruits = []; // 创建一个数组

fruits[99999] = 5; // 用一个远大于数组长度的索引分配属性

fruits.age = 25; // 用任意的名字创建属性
```

这是可能的，因为数组是基于对象的。我们可以给它们添加任何属性。

但是 Javascript 引擎会发现我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，而且还会被关闭，这些优化所带来的优势也就荡然无存了。

数组误用的几种方式:

- 添加一个非数字的属性比如 `arr.test = 5`。
- 制造空洞，比如：添加 `arr[0]` 后添加 `arr[1000]` (它们中间什么都没有)。
- 以倒序填充数组, 比如 `arr[1000]`，`arr[999]` 等等。

请将数组视为作用于**有序数据**的特殊结构，它们为此提供了特殊的方法。数组在 JavaScript 引擎内部是经过特殊调整的，使得更好的作用于连续的有序数据，所以请以这种方式使用数组。如果你需要任意键值，那很有可能实际上你需要的是常规对象 `{}`。

##### [性能](https://zh.javascript.info/array#xing-neng)

`push/pop` 方法运行的比较快，而 `shift/unshift` 比较慢。

![image-20191022135244126](/Users/silver/Library/Application Support/typora-user-images/image-20191022135244126.png)

为什么作用于数组的末端会比前端快呢？让我们看看在执行期间都发生了什么：

```javascript
fruits.shift(); // 从前端取出一个元素
```

只获取并移除数字 `0` 对应的元素是不够的。其它元素也需要被重新编号。

`shift` 操作必须做三件事:

1. 移除索引为 `0` 的元素。
2. 把所有的元素向左移动，将索引从 `1` 改成 `0`，`2` 改成 `1` 以此类推，对其重新编号。
3. 更新 `length` 属性。

![image-20191022135317731](/Users/silver/Library/Application Support/typora-user-images/image-20191022135317731.png)

**数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作。**

`unshift` 也是一样：为了在数组的前端添加元素，我们首先需要将现有的元素向右移动，增加它们的索引值。

那`push/pop` 是什么样的呢？它们不需要移动任何东西。如果从末端移除一个元素，`pop` 方法只需要清理索引值和缩短 `length` 就可以了。

`pop` 操作的动作:

```javascript
fruits.pop(); // 从末端取走一个元素
```

![image-20191022135341938](/Users/silver/Library/Application Support/typora-user-images/image-20191022135341938.png)

**pop 方法不需要移动任何东西，因为其它元素都保留了各自的索引。这就是为什么 pop 会特别快。**

`push` 方法也是一样的。

##### [循环](https://zh.javascript.info/array#xun-huan)

遍历数组最古老的方式就是 `for` 循环

```javascript
let arr = ["Apple", "Orange", "Pear"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

但对于数组来说还有另一种循环方式，`for..of` ：

```javascript
let fruits = ["Apple", "Orange", "Plum"];

// 迭代数组元素
for (let fruit of fruits) {
  alert( fruit );
}
```

`for..of` 不能获取当前元素的索引，但大多数情况是够用的。而且这样写更短。

技术上来讲，因为数组也是对象，所以使用 `for..in` 也是可能的：

```javascript
let arr = ["Apple", "Orange", "Pear"];

for (let key in arr) {
  alert( arr[key] ); // Apple, Orange, Pear
}
```

但这其实不是个好想法。会有一些潜在问题存在：

1. `for..in` 循环会迭代**所有属性**，不仅仅是这些数字属性。

   在浏览器和其它环境中有一种“类数组”的对象，它们**看似是数组**，也就是说，它们有 `length` 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。`for..in` 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。

2. `for..in` 循环适用于普通对象，不适用于数组，而且会慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈或者一些不相关的场景增速可能会有问题。但是我们仍然应该了解这其中的不同。

通常来说，我们不应该用 `for..in` 来处理数组。

##### [关于 “length”](https://zh.javascript.info/array#guan-yu-length)

当我们修改数组的时候，`length` 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。

例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 `length` 也会很大：

```javascript
let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); // 124
```

要知道的是我们通常不会这样使用数组。

`length` 属性的另一个有意思的点是它是可写的。

如果我们手动增加长度，一切正常。但是如果我们减少长度，数组就会变短。这种处理是不可逆的，下面是一个例子：

```javascript
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 只剩 2 个元素
alert( arr ); // [1, 2]

arr.length = 5; // 又把 length 加回来
alert( arr[3] ); // undefined: 被截断的那些数值并没有回来
```

所以，清空数组最好的方法就是：`arr.length = 0;`。

##### [new Array()](https://zh.javascript.info/array#new-array)

创建数组还有另一种语法：

```javascript
let arr = new Array("Apple", "Pear", "etc");
```

它很少被使用，因为方括号 `[]` 更短更简洁。而且这种语法还存在一些诡异的特性。

如果调用 `new Array` 使用的是一个单独的数字作为参数，那么就会创建一个**指定了长度，却没有任何项**的数组。

让我们看看如何搬起石头砸自己的脚:

```javascript
let arr = new Array(2); // 会创建一个数组 [2] 吗？

alert( arr[0] ); // undefined！没有元素.

alert( arr.length ); // length 2
```

在上面的代码中，`new Array(number)` 所有的元素都是 `undefined`

为了避免这种乌龙事件，我们通常都是使用方括号的，除非我们清楚地知道自己正在做什么。

##### [多维数组](https://zh.javascript.info/array#duo-wei-shu-zu)

数组里的项也可以是数组。我们可以以多维数组的方式存储矩阵：

```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 最中间的那个数
```

##### [toString](https://zh.javascript.info/array#tostring)

数组有自己的 `toString` 方法的实现，会返回以逗号隔开的元素列表。

例如：

```javascript
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```

或者尝试一下这个：

```javascript
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```

数组没有 `Symbol.toPrimitive`，也没有 `valueOf`，它们只能执行 `toString` 进行转换，所以这里 `[]` 就变成了一个空字符串，`[1]` 变成了 `"1"` 然后 `[1,2]` 变成了 `"1,2"`。

当 `"+"` 操作符把一些项加到字符串后面时，加号后面的项也会被转换成字符串，所以下一步就会是这样：

```javascript
alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
```

##### [总结](https://zh.javascript.info/array#zong-jie)

数组是一种特殊的对象，适用于存储和管理有序的数据项。

- 声明:

  ```javascript
  // 方括号 (常见用法)
  let arr = [item1, item2...];
  
  // new Array (极其少见)
  let arr = new Array(item1, item2...);
  ```

  调用 `new Array(number)` 会创建一个指定长度的数组，且不含有任何项。

- `length` 属性是数组的长度，准确地说，是它的最后一个数字索引值加一。它由数组方法自动调整。

- 如果我们手动缩短 `length`，那么数组就会被截断。

我们可以通过下列操作以双端队列的方式使用数组：

- `push(...items)` 在末端添加项 `items`。
- `pop()` 从末端移除并返回该元素。
- `shift()` 从前端移除并返回该元素。
- `unshift(...items)` 从前端添加项 `items`。

遍历数组的元素：

- `for (let i=0; i<arr.length; i++)` — 运行的最快, 可兼容旧版本浏览器。
- `for (let item of arr)` — 现代语法，只能访问 items。
- `for (let i in arr)` — 永远不会使用。

##### [习题:最大子数组](https://zh.javascript.info/array#zui-da-zi-shu-zu)

重要程度: 2

输入是以数字组成的数组，例如 `arr = [1, -2, 3, 4, -9, 6]`.

任务是：找出连续的 `arr` 的子数组，其里面所有项的和最大。

写出函数 `getMaxSubSum(arr)`，用其找出并返回最大和。

例如：

```javascript
                                               getMaxSubSum([-1, 2, 3, -9]) = 5 (高亮项的加和)
getMaxSubSum([2, -1, 2, 3, -9]) = 6
getMaxSubSum([-1, 2, 3, -9, 11]) = 11
getMaxSubSum([-2, -1, 1, 2]) = 3
getMaxSubSum([100, -9, 2, -3, 5]) = 100
getMaxSubSum([1, 2, 3]) = 6 (所有项的和)
```

如果所有项都是负数，那就一个项也不取（数组是空的），所以返回的是 0：

```javascript
getMaxSubSum([-1, -2, -3]) = 0
```

请尝试想出一个快速的解决方案：复杂度可以是 [O(n2)](https://en.wikipedia.org/wiki/Big_O_notation)，有能力达到 O(n) 则更好。

在下一章节我们会回顾数组然后学习更多添加、移动、提取元素和数组排序的方法。 [数组方法](https://zh.javascript.info/array-methods)。

解答:

```javascript
function getMaxSubSum (arr) {
  let max = 0;
  // if (arr.length === 0) {
  //   return max;
  // }
  let tmp = 0;
  for (let num of arr) {
    if (tmp + num > 0) {
      tmp = tmp + num;
      max = Math.max(max, tmp);
    } else {
      tmp = 0;
    }
  }
  return max;
}
```

#### 4.4数组方法

因为数组提供的方法很多。为了方便起见，在本章中，我们将按组讲解。

##### [添加/移除数组元素](https://zh.javascript.info/array-methods#tian-jia-yi-chu-shu-zu-yuan-su)

已知从开头或结尾添加删除元素的方法：

- `arr.push(...items)` — 从结尾添加元素，
- `arr.pop()` — 从结尾提取元素，
- `arr.shift()` — 从开头提取元素，
- `arr.unshift(...items)` — 从开头添加元素，

这里还有其他几种方法。

###### [splice](https://zh.javascript.info/array-methods#splice)

如何从数组中删除元素？

数组是对象，所以我们可以尝试使用 `delete`：

```javascript
let arr = ["I", "go", "home"];

delete arr[1]; // remove "go"

alert( arr[1] ); // undefined

// now arr = ["I",  , "home"];
alert( arr.length ); // 3
```

元素被删除，但数组仍然有 3 个元素，我们可以看到 `arr.length == 3`。

这很正常，因为 `delete obj.key` 是通过 `key` 来移除对应的值。但是对于数组，我们通常希望剩下的元素移除并释放占用的位置，得到一个更短的数组。

所以应该使用特殊的方法。

[arr.splice(str)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) 方法可以说是数组界的瑞士军刀。它可以做所有事情：添加，删除和插入元素。

语法是：

```javascript
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

从 `index` 开始：删除 `deleteCount` 元素并在当前位置插入 `elem1, ..., elemN`。最后返回已删除元素的数组。

这个方法很容易通过例子来掌握。

让我们从删除开始：

```javascript
let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // from index 1 remove 1 element

alert( arr ); // ["I", "JavaScript"]
```

简单，对吧？从索引 `1` 开始删除 `1` 个元素。

在下一个例子中，我们删除了 3 个元素，并用另外两个元素替换它们：

```javascript
                                                                           let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 3 first elements and replace them with another
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
```

在这里我们可以看到 `splice` 返回已删除元素的数组：

```javascript
                        let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 2 first elements
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- 被删除元素的数组
```

我们可以将 `deleteCount` 设置为 `0`，`splice` 方法就能够插入元素而不用删除：

```javascript
let arr = ["I", "study", "JavaScript"];

// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```

###### [slice:返回的是一个新的对象](https://zh.javascript.info/array-methods#slice)

[arr.slice](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) 方法比 `arr.splice` 简单得多。

语法是：

```javascript
arr.slice(start, end)
```

它从所有元素的开始索引 `"start"` 复制到 `"end"` (不包括 `"end"`) 返回一个新的数组。`start` 和 `end` 都可以是负数，在这种情况下，从末尾计算索引。

它和字符串的 `str.slice` 有点像，就是把子字符串替换成子数组。

例如：

```javascript
let str = "test";
let arr = ["t", "e", "s", "t"];

alert( str.slice(1, 3) ); // es
alert( arr.slice(1, 3) ); // e,s

alert( str.slice(-2) ); // st
alert( arr.slice(-2) ); // s,t
```

###### [conncat](https://zh.javascript.info/array-methods#concat)

[arr.concat](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) 将数组与其他数组和/或元素结合在一起。

语法：

```javascript
arr.concat(arg1, arg2...)
```

它接受任意数量的参数 — 数组或值。

结果是一个包含`arr`，`arg1`，`arg2`等元素的新数组。

如果参数是一个数组或具有 `Symbol.isConcatSpreadable` 属性，则其所有元素都将被复制。否则，复制参数本身。

例如：

```javascript
let arr = [1, 2];

// merge arr with [3,4]
alert( arr.concat([3, 4])); // 1,2,3,4

// merge arr with [3,4] and [5,6]
alert( arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6

// merge arr with [3,4], then add values 5 and 6
alert( arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6
```

通常，它只复制数组中的元素（“扩展”它们）。其他对象，即使它们看起来像数组一样，仍然作为一个整体添加：

```javascript
let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
//[1, 2, arrayLike]
```

…但是，如果类似数组的对象具有 [`Symbol.isConcatSpreadable`](https://cloud.tencent.com/developer/section/1192208) 属性，将替换其元素：

```javascript
let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```

##### [查询数组](https://zh.javascript.info/array-methods#cha-xun-shu-zu)

###### [indexOf/lastIndexOf 和 includes](https://zh.javascript.info/array-methods#indexoflastindexof-he-includes)

[arr.indexOf](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)、[arr.lastIndexOf](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf) 和 [arr.includes](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/includes) 方法与字符串操作具有相同的语法，只不过这里是对数组元素而不是字符进行操作：

- `arr.indexOf(item, from)` 从索引 `from` 查询 `item`，如果找到返回索引，否则返回 `-1`。
- `arr.lastIndexOf(item, from)` — 和上面相同，只是从尾部开始查询。
- `arr.includes(item, from)` — 从索引 `from` 查询 `item`，如果找到则返回 `true`。

例如：

```javascript
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```

请注意，这些方法使用 `===` 比较。所以如果我们查询 `false`，会精确到是 `false` 而不是零。

如果我们想检查是否包含需要的元素，并且不想知道确切的索引，那么 `arr.includes` 是首选。

此外，`includes` 的一个非常小的差别是它能正确处理`NaN`，而不像 `indexOf/lastIndexOf`：

```javascript
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (should be 0, but === equality doesn't work for NaN)
alert( arr.includes(NaN) );// true (correct)
```

###### [find 和 findIndex](https://zh.javascript.info/array-methods#find-he-findindex)

想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？

这时可以用 [arr.find](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/find) 方法。

语法：

```javascript
let result = arr.find(function(item, index, array) {
  // 如果查询到返回 true
});
```

该函数对数组中的每个元素重复调用：

- `item` 是元素。
- `index` 是它的索引。
- `array` 是数组本身。

如果它返回`true`，则查询停止，返回 `item`。如果没有查询到，则返回 `undefined`。

例如，我们有一组用户，每个用户都有 `id` 和 `name` 字段。让我们找到一个 `id == 1`：

```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```

在现实生活中，对象数组是很常见，所以`find` 方法非常有用。

注意在这个例子中我们传给了 `find` 一个单参数函数 `item => item.id == 1`。其他参数 `find` 很少使用。

与 [arr.findIndex](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) 方法本质上是相同的，但它返回找到元素的索引而不是元素本身。

###### [filter](https://zh.javascript.info/array-methods#filter)

`find` 方法查询的是使函数返回 `true` 的第一个元素。

如果需要匹配的有很多，我们可以使用 [arr.filter(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)。

语法与 `find` 大致相同，但是它返回的是所有匹配元素组成的数组：

```javascript
let results = arr.filter(function(item, index, array) {
  // 在元素通过过滤器时返回 true
});
```

例如：

```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// 返回前两个用户的数组
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

##### [转换数组](https://zh.javascript.info/array-methods#zhuan-huan-shu-zu)

###### [map](https://zh.javascript.info/array-methods#map)

[arr.map](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/map) 方法是最有用和经常使用的方法之一。

语法：

```javascript
let result = arr.map(function(item, index, array) {
  // 返回新值而不是当前元素
})
```

它对数组中每个元素调用函数并返回符合结果的数组。

例如，在这里我们将每个元素转换为它的字符串长度：

```javascript
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length)
alert(lengths); // 5,7,6
```

###### [sort(fn)](https://zh.javascript.info/array-methods#sortfn)

[arr.sort](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) 方法对数组**进行排序**

语法：

```javascript
                          let arr = [ 1, 2, 15 ];

// 该方法重新排列 arr 的内容（并返回它）
arr.sort();

alert( arr );  // 1, 15, 2
```

你有没有注意到结果有什么奇怪的地方？

顺序变成了 `1, 15, 2`。不对，但为什么呢？

**这些元素默认情况下按字符串排序。**

从字面上看，所有元素都被转换为字符串，然后进行比较。因此，按照词典顺序排序，实际上应该是`"2" > "15"`。

要使用我们自己的排序顺序，我们需要提供带两个参数的函数作为 `arr.sort()` 的参数。

该函数像这样工作：

```javascript
function compare(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}
```

例如：

```javascript
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
```

现在结果符合预期了。

让我们搁置一边，思考发生了什么。`arr` 可以是由任何东西组成的数组。它可能包含数字或字符串或 html 元素或其他。我们对一组数据进行排序时，需要一个**排序函数**来确认如何比较这些元素。默认是按字符串排序的。

`arr.sort(fn)` 方法内置实现排序算法。我们不需要关心它是如何工作的(大多数情况下是优化过的[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法)。它将自动遍历数组，使用提供的函数比较它的元素并对它们重新排序，我们所需要的只是提供用于比较的函数 `fn`。

顺便说一句，如果我们想知道哪些元素进行了比较 — alert 是没有作用的：

```javascript
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
});
```

该算法可以在过程中多次比较元素，但它会尽可能少地进行比较。

------

**比较函数可以返回任何数字**

实际上，比较函数只需要返回一个正数表示更大，而负数表示更少。

通过这个原理我们可以编写更短的函数：

```javascript
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
```

------

**箭头函数最好**

文章 "function-expression" 未找到还记得吗？这里使用箭头函数会更加简洁：

```javascript
arr.sort( (a, b) => a - b );
```

这与上面的那些更长的其它写法是完全相同的。

###### [reverse](https://zh.javascript.info/array-methods#reverse)

[arr.reverse](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse) 方法颠倒 `arr` 中元素的顺序。

例如：

```javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

它也在返回后返回数组 `arr`。

###### [split 和 join](https://zh.javascript.info/array-methods#split-he-join)

举一个现实生活的场景的例子，我们正在编写一个消息应用程序，并且该人员输入以逗号分隔的接收者列表：`John，Pete，Mary`。但对我们来说，数组比单个字符串更舒适。怎么做才能获得这个数组呢？

[str.split(delim)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/split) 方法可以做到。它通过给定的分隔符 `delim` 将字符串分割成一个数组。

在下面的例子中，我们用逗号分隔空格：

```javascript
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)
}
```

`split` 方法有一个可选的第二个数字参数 — 对数组长度的限制。如果提供了，那么额外的元素将被忽略。但实际上它很少使用：

```javascript
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```

------

**拆分为字母**

调用空的参数 `split(s)` 会将字符串分成一个字母数组：

```javascript
let str = "test";

alert( str.split('') ); // t,e,s,t
```

[arr.join(str)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/join) 与 `split` 相反。它会在它们之间创建一串由 `str` 粘合的 `arr` 项。

例如：

```javascript
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';');

alert( str ); // Bilbo;Gandalf;Nazgul
```

###### [reduce/reduceRight](https://zh.javascript.info/array-methods#reducereduceright)

当我们需要遍历一个数组时 — 我们可以使用 `forEach`。

当我们需要迭代并返回每个元素的数据时 — 我们可以使用 `map`。

[arr.reduce](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) 和 [arr.reduceRight](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight) 和上面差不多，但有点复杂。它们用于根据数组计算单个值。

语法是：

```javascript
let value = arr.reduce(function(previousValue, item, index, arr) {
  // ...
}, initial);
```

该函数应用于元素。从第二个参数开始你可能就会觉得很眼熟了：

- `item` — 当前的数组元素。
- `index` — 当前索引。
- `arr` — 数组本身。

目前为止，这很像 `forEach/map`。但还有一个参数不同就是：

- `previousValue` — 是前一个函数调用的结果，第一次调用是初始化。

我们写个例子试试。

这里我们得到一行数组的总和：

```javascript
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

在这里，我们使用了 `reduce` 的最常见类型，它只使用 2 个参数。

让我们看看发生了什么的细节。

1. 在第一次运行时，`sum` 是初始值（`reduce` 的最后一个参数），等于 0，`current` 是第一个数组元素，等于 1。所以结果是 `1`。
2. 在第二次运行时，`sum = 1`，我们添加第二个数组元素（`2`）并返回。
3. 在第三次运行中，`sum = 3`，我们再添加一个元素，等等……

计算流程：

![image-20191022151509856](/Users/silver/Library/Application Support/typora-user-images/image-20191022151509856.png

或者以表格的形式出现，每行代表的是下一个数组元素的函数调用：

|                 | `sum` | `current` | `result` |
| :-------------- | :---- | :-------- | :------- |
| the first call  | `0`   | `1`       | `1`      |
| the second call | `1`   | `2`       | `3`      |
| the third call  | `3`   | `3`       | `6`      |
| the fourth call | `6`   | `4`       | `10`     |
| the fifth call  | `10`  | `5`       | `15`     |

正如我们所看到的，先前调用的结果成为下一个调用的第一个参数。

我们也可以省略初始值：

```javascript
let arr = [1, 2, 3, 4, 5];

// 删除初始值
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
```

结果是一样的。这是因为如果没有初始值，那么 `reduce` 将数组的第一个元素作为初始值，并从第二个元素开始迭代。

计算表与上面相同，减去第一行

但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 `reduce` 会导致错误。

例如：

```javascript
let arr = [];

// Error: Reduce of empty array with no initial value
// 如果初始值存在，reduce 将返回空 arr。
arr.reduce((sum, current) => sum + current);
```

所以建议始终指定初始值。

[arr.reduceRight](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight) 也一样，但是遍历是从右到左。

###### [迭代：forEach](https://zh.javascript.info/array-methods#die-dai-foreach)

[arr.forEach](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) 方法允许为数组的每个元素运行一个函数。

语法：

```javascript
arr.forEach(function(item, index, array) {
  // ... do something with item
});
```

例如，这显示了数组的每个元素：

```javascript
// 为每个元素调用 alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
```

而这段代码更详细地介绍了它们在数组中的位置

```javascript
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```

该函数的结果（如果它返回的话）被抛弃并被忽略。

##### [Array.isArray](https://zh.javascript.info/array-methods#arrayisarray)

数组基于对象。不构成单独的语言类型。

所以 `typeof` 无法从对象中区分出数组来：

```javascript
alert(typeof {}); // object
alert(typeof []); // same
```

……但是数组经常被使用，以至于有一种特殊的方法用于判断：[Array.isArray(value)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)。如果 `value` 是一个数组，则返回 `true`；否则返回 `false`。

```javascript
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
```

##### [大多数方法支持 “thisArg”](https://zh.javascript.info/array-methods#da-duo-shu-fang-fa-zhi-chi-thisarg)

几乎所有调用函数的数组方法 – 比如 `find`，`filter`，`map`，与带有 `sort` 的不同，他们接受一个可选的附加参数 `thisArg`。

该参数在上面的部分没有解释，因为它很少使用。但为了完整性，我们还需要解释下。

以下是这些方法的完整语法：

```javascript
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg 是可选的最后一个参数
```

`thisArg` 参数的值在 `func` 中变为 `this`。

例如，在这里我们使用一个对象方法作为过滤器，`thisArg` 派上用场：

```javascript
let user = {
  age: 18,
  younger(otherUser) {
    return otherUser.age < this.age;
  }
};

let users = [
  {age: 12},
  {age: 16},
  {age: 32}
];

// 找到比 user 小的所有 users
let youngerUsers = users.filter(user.younger, user);

alert(youngerUsers.length); // 2
```

在上面我们使用 `user.younger` 作为过滤器，并提供 `user` 作为它的上下文。如果我们没有提供上下文，`users.filter(user.younger)` 会调用`user.younger` 作为一个独立的函数，这时 `this=undefined`。

##### [总结](https://zh.javascript.info/array-methods#zong-jie)

数组方法备忘录：

- 添加/删除元素：
  - `push(...items)` — 从结尾添加元素，
  - `pop()` — 从结尾提取元素，
  - `shift()` — 从开头提取元素，
  - `unshift(...items)` — 从开头添加元素，
  - `splice(pos, deleteCount, ...items)` — 从 `index` 开始：删除 `deleteCount` 元素并在当前位置插入元素。
  - `slice(start, end)` — 它从所有元素的开始索引 `"start"` 复制到 `"end"` (不包括 `"end"`) 返回一个新的数组。
  - `concat(...items)` — 返回一个新数组：复制当前数组的所有成员并向其中添加 `items`。如果有任何`items` 是一个数组，那么就取其元素。
- 查询元素：
  - `indexOf/lastIndexOf(item, pos)` — 从 `pos` 找到 `item`，则返回索引否则返回 `-1`。
  - `includes(value)` — 如果数组有 `value`，则返回 `true`，否则返回 `false`。
  - `find/filter(func)` — 通过函数过滤元素，返回 `true` 条件的符合 find 函数的第一个值或符合 filter 函数的全部值。
  - `findIndex` 和 `find` 类似，但返回索引而不是值。
- 转换数组：
  - `map(func)` — 从每个元素调用 `func` 的结果创建一个新数组。
  - `sort(func)` — 将数组倒序排列，然后返回。
  - `reverse()` — 在原地颠倒数组，然后返回它。
  - `split/join` — 将字符串转换为数组并返回。
  - `reduce(func, initial)` — 通过为每个元素调用 `func` 计算数组上的单个值并在调用之间传递中间结果。
- 迭代元素：
  - `forEach(func)` — 为每个元素调用 `func`，不返回任何东西。
- 其他：  – `Array.isArray(arr)` 检查 `arr` 是否是一个数组。

请注意，`sort`，`reverse` 和 `splice` 方法修改数组本身。

这些方法是最常用的方法，它们覆盖 99％ 的用例。但是还有其他几个：

- [arr.some(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/some)/[arr.every(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/every) 检查数组。

  在类似于 `map` 的数组的每个元素上调用函数 `fn`。如果任何/所有结果为 `true`，则返回 `true`，否则返回 `false`。

- [arr.fill(value, start, end)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) — 从 `start` 到 `end` 用 `value` 重复填充数组。

- [arr.copyWithin(target, start, end)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin) — copies its elements from position `start` till position `end` into *itself*, at position `target` (overwrites existing).将其元素从 `start` 到 `end` 在 `target` 位置复制到 **本身**（覆盖现有）。

  例如：

  ```javascript
  let array1 = ['a', 'b', 'c', 'd', 'e'];
  
  // copy to index 0 the element at index 3
  console.log(array1.copyWithin(0, 3, 4));
  // expected output: Array ["d", "b", "c", "d", "e"]
  
  // copy to index 1 all elements from index 3 to the end
  console.log(array1.copyWithin(1, 3));
  // expected output: Array ["d", "d", "e", "d", "e"]
  
  ```

有关完整列表，请参阅[手册](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array)。

从第一眼看来，似乎有很多方法，很难记住。但实际上这比看起来要容易得多。

为了您有数组方法的经验，请仔细查看备忘单了解它们。然后解决本章的任务练习。

以后，当你需要对某个数组操作，而无从下手 — 可以来到这，查看备忘录并找到正确的方法。示例将帮助您正确编写它。很快你会自动记住这些方法，而无需你额外的努力。

##### 习题

随机排序，sort内部排序函数想法很突破，利用random随机生成0-1的浮点数减去0.5的方式，使得正序逆序概率都为50%，但是测试其实达不到每种情况相同概率。

```javascript
function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}
```

故不可直接使用sort这个黑匣子完成这一操作，但是还有其他很好的方法来完成这项任务。例如，有一个很好的算法叫做 [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle)。其思路是：逆向遍历数组，并将每个子项与前面随机的一个子项互相交换：

```javascript
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // r 从 0 到 i 的随机索引
    [array[i], array[j]] = [array[j], array[i]]; // 交换元素
  }
}
```

#### 4.5Iterables（可迭代对象）

**Iterable** （可迭代对象）是数组的泛化。这个概念是说任何对象都可在 `for..of` 循环中使用。

数组本身就是可迭代的。但不仅仅是数组。字符串也可以迭代，很多其他内建对象也都可以迭代。

在核心 JavaScript 中，可迭代对象用途广泛。我们将会看到，很多内建的操作和方法都依赖于它。

##### [Symbol.iterator](https://zh.javascript.info/iterable#symboliterator)

通过自己创建一个可迭代对象，我们就可以很容易的掌握它的概念。

例如，我们有一个对象，它并不是数组，但是看上去很适合使用 `for..of` 循环。

比如一个 `range` 对象，代表了一个数字区间：

```javascript
let range = {
  from: 1,
  to: 5
};

// 我们希望 for..of 这样运行：
// for(let num of range) ... num=1,2,3,4,5
```

为了让 `range` 对象可迭代（也就让 `for..of` 可以运行）我们需要为对象添加一个名为 `Symbol.iterator`的方法（一个特殊的内置标记）。

- 当 `for..of` 循环开始，它将会调用这个方法（如果没找到，就会报错）。
- 这个方法必须返回一个迭代器 —— 一个有 `next` 方法的对象。
- 当 `for..of` 循环希望取得下一个数值，它就调用这个对象的 `next()` 方法。
- `next()` 返回结果的格式必须是 `{done: Boolean, value: any}`，当 `done=true` 时，表示迭代结束，否则 `value` 必须是一个未被迭代的新值。

这是 `range` 的全部实现：

```javascript
let range = {
  from: 1,
  to: 5
};

// 1. 使用 for..of 将会首先调用它：
range[Symbol.iterator] = function() {

  // 2. ...它返回一个迭代器：
  return {
    current: this.from,
    last: this.to,

    // 3. next() 将在 for..of 的每一轮循环迭代中被调用
    next() {
      // 4. 它将会返回 {done:.., value :...} 格式的对象
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// 现在它可以运行了！
for (let num of range) {
  alert(num); // 1, 然后 2, 3, 4, 5
}
```

这段代码中有几点需要着重关注：

- `range` 自身没有 `next()` 方法。
- 相反，是调用 `range[Symbol.iterator]()` 时将会被创建的另一个所谓的“迭代器”对象，将会处理迭代操作。

所以，迭代器对象和迭代的对象其实是分离的。

技术上说，我们可以将它们合并，用 `range` 自身作为迭代器来简化代码。

就像这样：

```javascript
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, 然后 2, 3, 4, 5
}
```

现在 `range[Symbol.iterator]()` 返回了 `range` 对象自身：它包括了必需的 `next()` 方法并通过 `this.current` 记忆了当前迭代进程。有时候，这样也可以。但缺点是，现在不可能同时在 `range` 上运行两个 `for..of` 循环了：这两个循环将会共享迭代状态，因为仅有一个迭代器 —— 也就是对象自身。

**`Symbol.iterator`方法返回的是一个迭代器对象，个人感觉第一种模式更为合理，看完这个突然想到ES6的新玩意`generator`，有点类似都是内部封装了一个next方法，可以一起学习下。**

------

无穷迭代也是可行的。例如，`range` 设置为 `range.to = Infinity` 则成为无穷迭代。或者我们可以创建一个可迭代对象，它生成一个伪随机数无穷序列。也是可用的。

`next` 没有什么限制，它可以返回越来越多的值，这也很常见。

当然，迭代这种对象的 `for..of` 循环将不会停止。但是我们可以通过使用 `break` 来打断它。

##### [字符串可迭代](https://zh.javascript.info/iterable#zi-fu-chuan-ke-die-dai)

数组和字符串是应用最广泛的内建可迭代对象。

对于一个字符串，`for..of` 循环它的每个字符：

```javascript
for (let char of "test") {
  alert( char ); // t，然后 e，然后 s，然后 t
}
```

对于 UTF-16 的扩展字符，它也能正常工作！

```javascript
let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳，然后 😂
}
```

##### [显式调用迭代器](https://zh.javascript.info/iterable#xian-shi-tiao-yong-die-dai-qi)

通常情况下，迭代器的内部函数对外部代码是隐藏的。`for..of` 循环可以工作，就是代码需要了解的所有内容了。

但是为了更深层的了解知识概念，我们来看看如何显式的创建迭代器。

我们将会采用与 `for..of` 一样的方法迭代字符串，但是是直接的调用。这段代码将会获取字符串的迭代器，然后“手动”调用它。

```javascript
let str = "Hello";

// 和下面代码完成的功能一致
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // 一个一个输出字符
}
```

很少需要我们这样做，但是却给我们比 `for..of` 对迭代过程更多的控制。例如，我们可以将迭代过程分散开：迭代一部分，然后停止，做一些其他处理，然后在稍后恢复迭代。

##### [可迭代对象和类数组对象](https://zh.javascript.info/iterable#array-like)

这两个正式的术语很相似，但是却非常不同。请你确保良好的掌握它们，并避免混淆。

- **Iterables** 是应用于 `Symbol.iterator` 方法的对象，像上文所述。
- **Array-likes** 是有索引和 `length` 属性的对象，所以它们很像数组。

很自然的，这些属性都可以结合起来。例如，字符串既是可迭代对象（`for..of` 可以迭代字符串）也是类数组对象（它们有数字索引也有 `length` 属性）。

但是一个可迭代对象也许不是类数组对象。反之亦然，一个类数组对象可能也不可迭代。

例如，上面例子中的 `range` 是可迭代的，但并非类数组对象，因为它没有索引属性，也没有 `length` 属性。

这个对象则是类数组的，但是不可迭代：

```javascript
let arrayLike = { // 有索引和长度 => 类数组对象
  0: "Hello",
  1: "World",
  length: 2
};

// 错误（没有 Symbol.iterator）
for (let item of arrayLike) {}
```

它们有什么共同点？可迭代对象和类数组对象通常都不是数组，他们没有 `push`，`pop` 等等方法。如果我们有一个这样的对象并且想像数组那样操作它，这就有些不方便了。

##### [Array.from](https://zh.javascript.info/iterable#arrayfrom)

###### 划重点

Array.from方法传入的参数一定是**类数组对象**或者**可迭代对象**

有一个全局方法 [Array.from](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 可以把它们全都结合起来。它以一个可迭代对象或者类数组对象作为参数并返回一个真正的 `Array` 数组。然后我们就可以用该对象调用数组的方法了。

例如：

```javascript
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World（pop 方法生效）
```

在行 `(*)`，`Array.from` 方法以一个对象为参数，检测到它是一个可迭代对象或类数组对象，然后将它转化为一个新的数组并将所有元素拷贝进去。

如果是可迭代对象，也是同样：

```javascript
// 假设 range 来自上文例子中
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 （数组的 toString 转化函数生效）
```

`Array.from` 的完整语法允许提供一个可选的 “mapping”（映射）函数：

```javascript
Array.from(obj[, mapFn, thisArg])
```

第二个参数 `mapFn` 应是一个在元素被添加到数组前，施加于每个元素的方法，`thisArg` 允许设置方法的 `this` 对象。

例如：

```javascript
// 假设 range 来自上文例子中

// 求每个数的平方
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
```

现在我们用 `Array.from` 将一个字符串转化为单个字符的数组：

```javascript
let str = '𝒳😂';

// 将 str 拆分为字符数组
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
```

不像 `str.split` 方法，上文的方法依赖于字符串的可迭代特性，所以就像 `for..of` 一样，能正确的处理 UTF-16 扩展字符。

技术上来说，它和下文做了同样的事：

```javascript
let str = '𝒳😂';

let chars = []; // Array.from 内部完成了同样的循环
for (let char of str) {
  chars.push(char);
}

alert(chars);
```

…但是精简很多。

我们甚至可以基于 `Array.from` 创建能处理 UTF-16 扩展字符的 `slice` 方法：

```javascript
function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// 原生方法不支持识别 UTF-16 扩展字符
alert( str.slice(1, 3) ); // 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）
```

###### Function.prototype.call()[](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)

看完了Array.from，我觉得有必要在提一下call方法，因为MDN上其实也介绍过使用该方法将类数组变为数组的方法。[链接看我看我](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)

```javascript
var args = Array.prototype.slice.call(arguments);
// 这句话其实就是让arguments调用了array的slice方法返回了一个新的数组对象，偷鸡取巧，牛批
var args = [].slice.call(arguments);

// ES2015
const args = Array.from(arguments);
const args = [...arguments];
```

##### [总结](https://zh.javascript.info/iterable#zong-jie)

可以应用 `for..of` 的对象被称为**可迭代的**。

- 技术上来说，可迭代对象必须实现方法`Symbol.iterator`。
  - `obj[Symbol.iterator]` 的结果被称为**迭代器**。由它处理更深入的迭代过程。
  - 一个迭代器必须有 `next()` 方法，它返回一个 `{done: Boolean, value: any}`，这里 `done:true`表明迭代结束，否则 `value` 就是下一个值。
- `Symbol.iterator` 方法会被 `for..of` 自动调用，但我们也可以直接调用。
- 内置的可迭代对象例如字符串和数组，都实现了 `Symbol.iterator`。
- 字符串迭代器能够识别 UTF-16 扩展字符。

有索引属性和 `length` 属性的对象被称为**类数组对象**。这种对象也许也有其他属性和方法，但是没有数组的内建方法。

如果我们深入了解规范 —— 我们将会发现大部分内建方法都假设它们需要处理可迭代对象或者类数组对象，而不是真正的数组，因为这样抽象度更高。

`Array.from(obj[, mapFn, thisArg])` 将可迭代对象或类数组对象 `obj` 转化为真正的 `Array` 数组，然后我们就可以对它应用数组的方法。可选参数 `mapFn` 和 `thisArg` 允许我们对每个元素都应用一个函数。

#### 4.6Map、Set、WeakMap 和 WeakSet

现在，我们已经学习了下面的比较复杂的数据结构：

- 对象：存储键值对的集合。
- 数组：存储有序集合。

但是，实际应用时还是不够。这就是 `Map` 和 `Set` 存在的原因。

##### [Map](https://zh.javascript.info/map-set-weakmap-weakset#map)

[Map](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Map) 是一个键值对的集合，很像 `Object`。但主要的区别是，`Map` 允许所有数据类型作为键。

主要的方法包括：

- `new Map()` – 创建 map。
- `map.set(key, value)` – 根据键（key）存储值（value）。
- `map.get(key)` – 根据键返回值，如果 map 中该键不存在，返回 `undefined`。
- `map.has(key)` – 如果键存在，返回 `true`，否则返回 `false`。
- `map.delete(key)` – 移除该键的值。
- `map.clear()` – 清空 map
- `map.size` – 返回当前元素个数。

例如：

```javascript
let map = new Map();

map.set('1', 'str1');   // 字符串作为 key
map.set(1, 'num1');     // 数字作为 key
map.set(true, 'bool1'); // 布尔值作为 key

// 还记得普通对象 Object 吗？它将会把所有的键转化为字符串类型
// 但是 Map 将会保留键的类型，所以下面这两个是不同的：
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
```

正如我们所见，不像普通对象，键并没有被转化为字符串。任何类型的键都是可以的。

**Map 可以使用对象作为键。**

例如：

```javascript
let john = { name: "John" };

// 存下每个用户的来访次数
let visitsCountMap = new Map();

// john 是 map 的键
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123
```

可以将对象用作键是 `Map` 最显著最重要的特点。对于字符串类型的键，`Object` 可以适用，但是对于上面这个例子，把 `Map` 替换成普通的对象 `Object` 就很困难了。

在 `Map` 类型存在之前的时候，人们将唯一标识加入对象来达成 `Map` 的功能：

```javascript
                                // 我们添加了一个 id 字段
let john = { name: "John", id: 1 };

let visitsCounts = {};

// 现在，通过 id 来保存值
visitsCounts[john.id] = 123;

alert( visitsCounts[john.id] ); // 123
```

…但是 `Map` 的写法更加优雅。

------

**How `Map` compares keys**

为了检测值是否相等，`Map` 使用了算法 [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero)。它大概就和严格等于号 `===` 相同，但区别是 `NaN` 等于 `NaN`。所以 `NaN` 也可以作为键。

该算法不能更改或用户定制。

------

**Chaining**

每次 `map.set` 的调用将会返回 map 自身，所以可以链式调用：

```javascript
map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
```

##### [将 Object 转化为 Map](https://zh.javascript.info/map-set-weakmap-weakset#jiang-object-zhuan-hua-wei-map)

当创建 `Map` 时，我们可以像这样传递一个数组（或其他可迭代对象）给构造函数：

```javascript
// [key, value] 键值对数组
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);
```

有一个内建方法 [Object.entries(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)，它可以返回一个对象的键值对数组，格式就和上面一样。

所以我们可以用一个对象来初始化一个 map，就像这样：

```javascript
let map = new Map(Object.entries({
  name: "John",
  age: 30
}));
```

这里，`Object.entries` 返回了键值对数组：`[ ["name","John"], ["age", 30] ]`。这正是 `Map` 需要的。

##### [遍历 Map](https://zh.javascript.info/map-set-weakmap-weakset#bian-li-map)

有三种方法可以循环遍历 `map`：

- `map.keys()` – 返回键的迭代器，
- `map.values()` – 返回值的迭代器，
- `map.entries()` – 返回 `[key, value]` 迭代器入口，`for..of` 循环会默认使用它。

例如：

```javascript
let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// 迭代键（vegetables）
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// 迭代值（amounts）
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// 迭代键值对 [key, value]
for (let entry of recipeMap) { // 和 recipeMap.entries() 一样
  alert(entry); // cucumber,500（等等）
}
```

------

**The insertion order is used**

和普通 `Object` 不同，迭代器的迭代顺序和值被插入的顺序一致，`Map` 会保留这个顺序。

------

另外，`Map` 有一个内建的 `forEach` 方法，和 `Array` 很像：

```javascript
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 等等
});
```

##### [Set](https://zh.javascript.info/map-set-weakmap-weakset#set)

`Set` 是一个值的集合，这个集合中所有的值仅出现一次。

主要方法包括：

- `new Set(iterable)` – 创建 set，利用数组来创建是可选的（任何可迭代对象都可以）。
- `set.add(value)` – 添加值，返回 set 自身。
- `set.delete(value)` – 删除值，如果该 `value` 在调用方法的时候存在则返回 `true` ，否则返回 `false`。
- `set.has(value)` – 如果 set 中存在该值则返回 `true` ，否则返回 `false`。
- `set.clear()` – 清空 set。
- `set.size` – 元素个数。

例如，我们有访客登门，我们希望记住所有人。但是重复来访者并不应该有两份记录。一个访客必须只记录一次。

`Set` 就恰好是可以做到这个的数据结构：

```javascript
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// 访客，一些用户来了多次
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set 保证了值的唯一
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // John（然后是 Pete 和 Mary）
}
```

`Set` 的替换方案是使用用户数组，每次插入新元素时使用 [arr.find](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/find) 方法检查用户编码是否重复。但是性能就会很差，因为这个方法会遍历整个数组，检查每个元素。而对于唯一性检查，`Set` 在内部优化得更好。

##### [Set 迭代](https://zh.javascript.info/map-set-weakmap-weakset#set-die-dai)

我们可以使用 `for..of` 或者 `forEach` 来循环查看 set：

```javascript
let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// 和 forEach 相同：
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```

注意到这里有个有趣得事情。`forEach` 函数用于 `Set` 时有三个参数：value，然后又一个 value，之后是目标对象。确实，相同值的 value 在参数中出现了两次。

这是为了兼容 `Map`，它在使用 `forEach` 方法时也包括三个参数。

适用于 `Map` 的迭代方法 set 也同样支持：

- `set.keys()` – 返回 set 中值的迭代对象，
- `set.values()` – 和 `set.keys` 一样，为了兼容 `Map`，
- `set.entries()` – 返回形如 `[value, value]` 的迭代对象，为了兼容 `Map` 而存在。

##### [WeakMap 和 WeakSet](https://zh.javascript.info/map-set-weakmap-weakset#weakmap-he-weakset)

`WeakSet` 是一种特殊的 `Set`，它不会阻止 JavaScript 将它的元素从内存中移除。`WeakMap` 和 `Map` 的区别也和上述一样。

正如我们在章节 [垃圾回收](https://zh.javascript.info/garbage-collection) 中了解到的，当该值可用（或可能需要）时，JavaScript 引擎将会把值缓存在内存中。

例如：

```javascript
let john = { name: "John" };

// 对象可被获取，john 是它的引用

// 覆盖引用
john = null;

// 对象将会从内存中移除
```

通常情况下，当某数据存在于内存中时，对象的属性或者数组的元素或其他的数据结构将被认为是可以获取的并留存于内存。

在一个正常 `Map` 中，我们将某对象存储为键还是值并不重要。它将会被一直保留在内存中，就算已经没有指向它的引用。

例如：

```javascript
let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // 覆盖引用

// john 被保存在 map 中
// 我们可以通过 map.keys() 得到它
```

除了 `WeakMap/WeakSet`。

**`WeakMap/WeakSet` 不会阻止内存移除对象。**

我们从 `WeakMap` 开始。

它和 `Map` 的第一个区别是它的键必须是对象，不能是基础类型的值：

```javascript
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // 运行正常（对象作为键）

weakMap.set("test", "Whoops"); // 错误，因为“test”是原始类型
```

现在，如果我们使用对象作为它的键，并且没有任何引用指向这个对象 —— 它将会自动被从内存中移除（也会从 map 中移除）。

```javascript
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // 覆盖引用

// john 从内存中移除了！
```

把它和上面普通 `Map` 的例子对比一下。现在，如果 `john` 仅作为 `WeakMap` 的键 —— 它将会被自动删除。

…并且 `WeakMap` 并不支持方法 `keys()`，`values()`，`entries()`，我们不能对它进行迭代。所以没有办法获取它的所有键值。

`WeakMap` 仅有如下方法：

- `weakMap.get(key)`
- `weakMap.set(key, value)`
- `weakMap.delete(key, value)`
- `weakMap.has(key)`

为什么会有这些限制？这是处于一些技术原因。如果一个对象没有任何引用（就像上面代码中的 `john`），那么它将会被自动删除。但是从技术上讲，它没有完全指定**什么时候清理会发生**。

JavaScript 引擎将会决定何时清理。它可能会选择马上清理内存或者等待：当更多需要删除操作发生的时候再删除。所以，技术上说，目前 `WeakMap` 中元素个数并不可知。引擎可能已经清理，也可能没有，也可能只进行了部分的清理。处于这个原因，允许访问 `WeakMap` 整体的方法并不支持。

现在，我们在哪里需要这样的结构？

`WeakMap` 的目的是，我们可以当且仅当该对象存在时，为对象存储一些内容。但我们并不会因为存储了对象的一些内容，就强制对象一直保留在内存中。

```javascript
weakMap.put(john, "secret documents");
// 如果 john 不存在了，secret documents 也将会被销毁
```

当我们对对象有个主存储区，并且需要保存仅当对象活跃时候才相关的附加信息时，这一点就很有用了。

让我们看一个例子。

例如，我们写了一段代码来保存每个用户的访问次数。信息保存在一个 map 中：用户是键，访问次数是值。当用户离开了，我们也就不再需要保存他的访问次数了。

有一个方法可以追踪离开的游客并手动清理记录：

```javascript
let john = { name: "John" };

// map: user => visits count
let visitsCountMap = new Map();

// john 是 map 的键
visitsCountMap.set(john, 123);

// 现在 john 离开了，我们不需要他了
john = null;

// 但是记录依旧在 map 中，我们需要清理它！
alert( visitsCountMap.size ); // 1
// 它还在内存中，因为 Map 将它作为键
```

另一个方法是使用 `WeakMap`：

```javascript
let john = { name: "John" };

let visitsCountMap = new WeakMap();

visitsCountMap.set(john, 123);

// 现在 john 离开了，我们不需要他了
john = null;

// 除了 WeakMap 没有其他引用了，
// 所以这个对象会自动的从内存和 visitsCountMap 中删除
```

使用普通的 `Map`，用户离开后的数据清理是一很乏味的任务：我们不仅要从主存储区移除用户（可能是变量或者数组），还需要将附加的数据存储例如 `visitsCountMap` 也清除。当用户在代码的一个位置进行管理，而附加结构位于另一个位置，并且没有获取有关清除的信息这样的复杂的情况下，这种操作就很笨重。

`WeakMap` 能让事情简单很多，因为它能够自动清理。它里面诸如上面的例子中来访次数这样的信息，当且仅当对象键存在的时候才存在。

`WeakSet` 的行为类似：

- 它和 `Set` 类似，但是我们仅能将对象添加进 `WeakSet`（不可以是基础类型）
- 仅当对象存在其他位置的引用时它才存在于 set 中。
- 就像 `Set` 一样，它支持 `add`，`has` 和 `delete`，不支持 `size`，`keys()` 也不支持迭代器。

例如，我们可以用它来追踪一个项目是否被检查过：

```javascript
let messages = [
    {text: "Hello", from: "John"},
    {text: "How goes?", from: "John"},
    {text: "See you soon", from: "Alice"}
];

// 用数组的元素来填充（3 个元素）
let unreadSet = new WeakSet(messages);

// 我们可以使用 unreadSet 来看一个 message 是否未读
alert(unreadSet.has(messages[1])); // true
// 读过之后就将它从 set 中移除
unreadSet.delete(messages[1]); // true

// 当我们对消息列表做 shift 操作，set 就会自动清理
messages.shift();
// 不需要清理 unreadSet，它现在还有两个元素
// 可惜并没有方法可以获取元素数目，所以无法显示出来
```

`WeakMap` 和 `WeakSet` 最显著的限制就是没有迭代器，也不能获取当前所有内容。这可能会有点不方便，但是实际上并不妨碍 `WeakMap/WeakSet` 的主要任务 —— 作为对象的附加存储，该对象在其他位置被保存或管理。

##### [总结](https://zh.javascript.info/map-set-weakmap-weakset#zong-jie)

- `Map` —— 是一个键值对集合

  和普通 `Object` 的区别：

  - 对象可以作为键。
  - 迭代顺序是插入顺序。
  - 附加方便的方法，有 `size` 属性。

- `Set` —— 是一个包含不重复值的集合。

  - 和 array 不同，set 不允许元素重新排序。
  - 保持插入的顺序。

- `WeakMap` —— `Map` 的一个变体，仅允许对象作为键，并且当对象由于其他原因不可引用的时候将其删除。

  - 它不支持整体的操作：没有 `size` 属性，没有 `clear()` 方法，没有迭代器。

- `WeakSet` —— 是 `Set` 的一个变体，仅存储对象，并且当对象由于其他原因不可引用的时候将其删除。

  - 同样不支持 `size/clear()` 和迭代器。

`WeakMap` 和 `WeakSet` 被用作主要对象存储的次要数据结构补充。一旦对象从存储移除，那么存在于 `WeakMap/WeakSet` 的数据将会被自动清除。

#### 4.7对象的键、值、项

单个数据结构告一段落，下面我们让讨论如何迭代它们。

在前面的章节中，我们认识了 `map.keys()`，`map.values()`，`map.entries()`。

这些方法是通用的，有一个共同的约定来将它们用于各种数据结构。如果我们创建一个我们自己的数据结构，我们也应该实现这些方法。

它们支持：

- `Map`
- `Set`
- `Array`（除了 `arr.values()`）

纯对象也支持类似的方法，但是语法上有一些不同

##### [Object.keys、values、entries 三个方法](https://zh.javascript.info/keys-values-entries#objectkeysvaluesentries-san-ge-fang-fa)

对于纯对象，下列方法是可用的：

- [Object.keys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) —— 返回一个包含该对象全部的键的数组。
- [Object.values(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/values) —— 返回一个包含该对象全部的值的数组。
- [Object.entries(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) —— 返回一个包含该对象全部 [key, value] 键值对的数组。

… 但是请注意区别（比如说跟 map 的区别）：

|          | Map          | Object                                  |
| :------- | :----------- | :-------------------------------------- |
| 调用语法 | `map.keys()` | `Object.keys(obj)`，而不是 `obj.keys()` |
| 返回值   | 可迭代项     | 「真正的」数组                          |

第一个区别是在对象中我们的调用语法是 `Object.keys(obj)`，而不是 `obj.keys()`。

为什么会这样？主要原因是保持灵活。请记住，在 JavaScript 中对象是所有复杂数据结构的基础。所以我们可能有一个我们自己创建的对象，比如 `order`，它实现了自己的方法 `order.values()`。同时，我们依然可以对它调用 `Object.values(order)` 方法。

第二个区别是 `Object.*` 方法返回的是「真正的」数组对象，而不是可迭代项。这主要是历史原因。

举个例子：

```javascript
let user = {
  name: "John",
  age: 30
};
```

- `Object.keys(user) = [name, age]`
- `Object.values(user) = ["John", 30]`
- `Object.entries(user) = [ ["name","John"], ["age",30] ]`

这里有一个使用 `Object.values` 来遍历属性值的例子：

```javascript
let user = {
  name: "John",
  age: 30
};

// 遍历所有的值
for (let value of Object.values(user)) {
  alert(value); // John, then 30
}
```

##### [Object.keys/values/entries 忽略 Symbol 类型的属性](https://zh.javascript.info/keys-values-entries#objectkeysvaluesentries-hu-lve-symbol-lei-xing-de-shu-xing)

就像 `for..in` 循环，这些方法会忽略使用 `Symbol(...)` 作为键的属性。

通常这很方便。但是如果我们也想要获得 Symbol 类型的键，那么有另外不同的方法 [Object.getOwnPropertySymbols](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)， 它会返回一个只包含 Symbol 类型的键的数组。同样，[Reflect.ownKeys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)方法会返回「所有」键。

#### 4.8解构赋值

JavaScript 中最常用的两种数据结构是 `Object`（对象）和 `Array`（数组）。

对象让我们能够把许多信息打包到一个单一的实体中，数组则让我们能够存放有序的集合。所以我们可以创建一个对象或一个数组，把它当作一个实体进行处理，或者把它当作参数传递给一个函数调用。

**解构赋值**是一种特殊的语法，它让我们可以将数组或对象进行“拆包”，存放到一系列的变量中，因为有时候使用变量更加方便。解构操作在那些具有很多参数和默认参数值的函数中也很奏效，很快我们就会看到这些都是怎么处理的。

##### [数组解构](https://zh.javascript.info/destructuring-assignment#shu-zu-jie-gou)

以下是将数组解构到变量中的一个例子：

```javascript
// 有一个存放了名字和姓氏的数组
let arr = ["Ilya", "Kantor"]

// 解构赋值
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
```

现在我们就可以针对这些变量进行操作，而不是针对原来的数组元素。

当与 `split` 函数（或其他返回值是数组的函数）结合使用时，看起来就更优雅了：

```javascript
let [firstName, surname] = "Ilya Kantor".split(' ');
```

------

**“解构"并不意味着"破坏”**

这种语法叫做“解构赋值”，因为它通过将结构中的各元素复制到变量中来达到“解构”的目的。但数组本身是没有被修改的。

也就是以下代码的更精简写法而已：

```javascript
// let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
```

------

**忽略第一个元素**

数组中不想要的元素也可以通过添加额外的逗号来把它丢弃：

```javascript
// 不需要第一个和第二个元素
let [, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
```

在以上的代码中，数组的第一个和第二个元素被跳过，第三个元素被赋值给了 `title` 变量，剩下的元素也被跳过了。

------

**用于等号右侧的任何可迭代对象**

…事实上我们也可以在任何可迭代对象中使用，不仅仅是数组：

```javascript
let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
```

------

**赋值给等号左侧的任何类型**

我们可以在等号左侧使用任何“可以被赋值的”变量。

例如，一个对象的属性：

```javascript
let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya
```

------

**使用 .entries() 循环**

在前面的章节中我们已经见过了 [Object.entries(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) 方法。

我们可以使用 .entries() 方法和解构语法来遍历一个对象的键-值对：

```javascript
let user = {
  name: "John",
  age: 30
};

// 循环遍历键-值对
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}
```

…对于 map 对象也类似：

```javascript
let user = new Map();
user.set("name", "John");
user.set("age", "30");

for (let [key, value] of user.entries()) {
  alert(`${key}:${value}`); // name:John, then age:30
}
```

###### [剩余的 ‘…’](https://zh.javascript.info/destructuring-assignment#sheng-yu-de)

如果我们不仅要获得第一个值，还要将后续的所有元素也收集起来——我们可以使用三个点 `"..."` 加一个参数来接收“剩余的”元素：

```javascript
                                                                                    let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar

alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
```

`rest` 变量的值就是数组中剩下的元素组成的数组。不一定要使用变量名 `rest`，我们也可以使用其他的变量名，只要确保它前面有三个点，并且在解构赋值的最后一个参数位置上就行了。

###### [默认值](https://zh.javascript.info/destructuring-assignment#mo-ren-zhi)

如果赋值语句中变量的数量多于数组中实际元素的数量，赋值不会报错。未赋值的变量被当作 `undifined`：

```javascript
let [firstName, surname] = [];

alert(firstName); // undefined
```

如果我们想要提供一个“默认值”给未赋值的变量，我们可以使用 `=` 来提供：

```javascript
// 默认值
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (来自数组的值)
alert(surname); // Anonymous (默认值被使用了)
```

默认值可以是更加复杂的表达式甚至可以是函数调用，这些表达式或函数只会在这个变量未被赋值的时候才会被计算。

举个例子，我们使用了 `prompt` 函数来提供两个默认值，但它只会在未被赋值的那个变量上进行调用：

```javascript
// 只会提示输入姓氏
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius (来自数组)
alert(surname); // 你输入的值
```

##### [对象解构](https://zh.javascript.info/destructuring-assignment#dui-xiang-jie-gou)

解构赋值同样适用于对象。

基本的语法是：

```javascript
let {var1, var2} = {var1:…, var2…}
```

在等号右侧有一个已经存在的对象，我们想把它拆开到变量中。等号左侧包含了对象相应属性的一个“模式”。以下简单例子中就是 `{...}` 中一系列变量。

举个例子：

```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```

属性 `options.title`、`options.width` 和 `options.height` 的值被赋给了对应的变量。变量的顺序并不重要，以下的代码也奏效：

```javascript
// 改变 let {...} 中属性的顺序
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
```

等号左侧的模式可以更加复杂，并给属性和变量之间指定一个映射关系。

如果我们想把一个属性赋值给不同名字的变量，比如把 `options.width` 属性赋值给变量 `w`，那可以使用冒号来指定：

```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { 原属性：目标变量 }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```

冒号表示了“什么值：赋值给谁”。以上的例子中就是属性 `width` 赋值给 `w`，属性 `height` 赋值给 `h`，属性 `title` 赋值给同名变量。

对于可能缺失的属性，我们可以使用 `"="` 来指定默认值，如下：

```javascript
let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```

就像数组或函数参数一样，默认值可以是表达式甚至是函数调用。只会在这个变量未被赋值的时候才会被计算/调用。

以下的代码提示输入宽度 width，但不会提示输入标题 title。

```javascript
let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // 你输入的宽度值
```

我们也可以结合冒号和等号一起使用：

```javascript
let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```

###### [剩余操作符](https://zh.javascript.info/destructuring-assignment#sheng-yu-cao-zuo-fu)

如果对象拥有的属性数量比我们提供的变量数量还多怎么办？我们可以只取其中的某一些属性然后把“剩余的”赋值到其他地方吗？

关于剩余操作符（即三个点）的文档几乎已经要被列为标准了，但大部分的浏览器还尚未支持。

看起来就像这样：

```javascript

let options = {
  title: "Menu",
  height: 200,
  width: 100
};

let {title, ...rest} = options;

// now title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
```

------

**不使用 `let` 的疑难病症**

在以上的例子中，变量都是在赋值前才被声明的：`let {…} = {…}`。当然，我们也可以使用已有的变量。但这里有一个问题需要注意。

以下代码无法正常运行：

```javascript
let title, width, height;

// 这一行发生错误
{title, width, height} = {title: "Menu", width: 200, height: 100};
```

问题在于 JavaScript 把主代码流（即不在其他表达式中）的 `{...}` 当做一个代码块，这样的代码块可以被用来组织语句，如下：

```javascript
{
  // 一个代码块
  let message = "Hello";
  // ...
  alert( message );
}
```

为了告诉 JavaScript 这不是一个代码块，我们可以把整个赋值表达式用括号 `(...)` 包起来：

```javascript
let title, width, height;

// 现在就正确了
({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
```

##### [嵌套解构](https://zh.javascript.info/destructuring-assignment#qian-tao-jie-gou)

如果一个对象或数组包含了其他的对象和数组，我们可以在等号左侧使用更复杂的模式来抽取深层的数据。

在以下代码中 `options` 的属性 `size` 是另一个对象，属性 `items` 是另一个数组。赋值语句中等号左侧的模式拥有相同的结构：

```javascript
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true    // 一些不会被解构的额外属性
};

// 为了清晰起见，解构赋值语句被写成多行
let {
  size: { // 把 size 赋值到这里
    width,
    height
  },
  items: [item1, item2], // 把 items 赋值到这里
  title = "Menu" // 在对象中不存在的属性（会使用默认值）
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
```

除了 `extra` 属性的整个 `options` 对象都能被赋值给对应的变量。

![image-20191024190705431](/Users/silver/Library/Application Support/typora-user-images/image-20191024190705431.png)

最终，我们得到了 `width`、`height`、`item1`、`item2` 和具有默认值的 `title` 变量。

有一个拥有很多属性的复杂对象，我们只想要抽取我们所需要的其中某些属性。这在解构赋值语句中是很常见的。

甚至还可能是这样的情况：

```javascript
// 将 size 作为一个整体取出赋值给一个变量，忽略剩下的所有
let { size } = options;
```

##### [智能函数参数](https://zh.javascript.info/destructuring-assignment#zhi-neng-han-shu-can-shu)

有时候一个函数可能有很多参数，大部分的参数是可选的，对用户界面来说就尤其如此。想象一下这种情况：有一个创建菜单的函数，可能有宽度参数，高度参数，标题参数和菜单中的菜单项等等。

以下是这种函数的一个不好的写法：

```javascript
function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}
```

现实情况下的问题就是你怎么记得住这么多参数的顺序，通常集成开发环境工具（IDE）会尽力帮助我们，特别是当代码有良好的文档注释的时候，但… 另一个问题就是当大部分的参数采用默认值就好的情况下，怎么调用这个函数。

难道像这样？

```javascript
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
```

这太难看了。而且当我们处理更多参数的时候可读性还会变得更差。

解构赋值语法前来救援！

我们可以把所有参数当作一个对象来传递，然后函数马上把这个对象解构成多个变量：

```javascript
                                                                             // 我们传递一个对象给函数
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...然后函数马上把对象展开成变量
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – 从 options 参数提取出来,
  // width, height – 使用默认值
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
```

我们同样可以对含有嵌套对象的对象使用更加复杂的结构语句和冒号映射：

```javascript
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width 赋值给 w
  height: h = 200, // height 赋值给 h
  items: [item1, item2] // items 第一个元素赋值给 item1, 第二个元素赋值给 item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
```

语法和解构赋值是一样的：

```javascript
function({
  incomingProperty: parameterName = defaultValue
  ...
})
```

请注意，这种解构假定了调用 `showMenu()` 函数时传递了一个参数，如果我们想让所有的参数都使用默认值，那我们应该传递一个空的对象：

```javascript
showMenu({});


showMenu(); // 这样会导致错误
```

我们可以通过指定空对象 `{}` 为整个函数参数的默认值：

```javascript
                                                                    // 清晰起见，精简了部分参数
function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
```

在以上的代码中，整个参数对象默认就是 `{}`，因此总会有对象可以用来解构。

##### [总结](https://zh.javascript.info/destructuring-assignment#zong-jie)

- 解构赋值允许将对象或数组立即映射到多个变量上。

- 解构对象的语法：

  ```javascript
  let {prop : varName = default, ...} = object
  ```

  这表示属性 `prop` 会被赋值给变量 `varName`，如果没有这个属性的话，就会使用 `default` 的值。

- 解构数组的语法：

  ```javascript
  let [item1 = default, item2, ...rest] = array
  ```

  数组的第一个元素赋值给 `item1`，第二个元素赋值给 `item2`，剩下的所有组成另一个数组 `rest`。

- 更多复杂的案例情况下，等号左侧必须和等号右侧有相同的结构。

#### 4.9日期和时间

让我一起探讨一个新的内置对象：[日期](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date)。该对象存储日期、时间以及提供管理它们的方法。

举个例子，我们可以使用它来存储创建、修改事件的时间，或者用来度量时间开销，再或者用来打印当前时间。

##### [创建](https://zh.javascript.info/date#chuang-jian)

创建一个新的 `Date` 对象，只需要调用 `new Date()`，附加下列参数中的其中一个：

`new Date()`

不带参数 —— 创建一个表示当前日期和时间的 `Date` 对象：

```javascript
let now = new Date();
alert( now ); // 显示当前的日期/时间
```

`new Date(milliseconds)`

创建一个 `Date` 对象，参数是从 1970-01-01 00:00:00 UTC+0 开始所经过的毫秒（一秒的千分之一）数。

```javascript
// 0 表示 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// 增加 24 小时，得到 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
```

传入的参数是自 1970-01-01 00:00:00 开始计算的毫秒数，被称为**时间戳**。

这是一种日期的轻量级表示方法。我们通常使用时间戳来创建一个日期，比如 `new Date(timestamp)`，以及使用 `date.getTime()` 来将现有的 `Date` 对象转化为时间戳（下面将提到）。

`new Date(datestring)`

如果只有一个参数，并且是字符串，那么该参数会通过 `Date.parse` 算法解析（下面会提到）。

```javascript
let date = new Date("2017-01-26");
alert(date); // Thu Jan 26 2017 ...
```

`new Date(year, month, date, hours, minutes, seconds, ms)`

创建一个 Date 对象，参数是当地时区的日期组合信息。只有前两个参数是必须的。

注意：

- `year` 必须是四位数：`2013` 是合法的，`98` 是不合法的。
- `month` 计数从 `0` （一月） 开始，到 `11` （12月）。
- `date` 是当月的具体某一天，如果缺失，默认是 `1`。
- 如果 `hours/minutes/seconds/ms` 缺失的话，它们默认值是 `0`。

举个例子：

```javascript
new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // 同样，时分秒等默认为 0
```

时间度量最小精确到 1 毫秒（千分之一秒）：

```javascript
let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
```

##### [访问日期组件](https://zh.javascript.info/date#fang-wen-ri-qi-zu-jian)

从 `Date` 对象中访问年、月等信息有很多种方式。通过分类可以很容易记忆。

- [getFullYear()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear)

  获取年份（4 位数）

- [getMonth()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth)

  获取月份**从 0 到 11**。

- [getDate()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate)

  获取当月的日期，从 1 到 31，这个方法名称可能看起来有些令人疑惑。

- [getHours()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours), [getMinutes()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes), [getSeconds()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds), [getMilliseconds()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds)

  获取相应的时间信息。

------

**不是 `getYear()`，而是 `getFullYear()`**

很多 JavaScript 引擎都实现了一个非标准化的方法 `getYear()`，这个方法不建议使用。它有可能返回 2 位的年份信息。请不要使用它。获取年份，使用 `getFullYear()`。

另外，我们还可以获取一周中的第几天：

- [getDay()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay)

  获取一周中的第几天，从 `0`（星期天）到 `6` （星期六）。第一天始终是星期天，在某些国家可能不是这样的习惯，但是这不能被改变。

**以上所有的方法返回的信息都是基于当地时区的。**

当然，也有与之对应的 UTC 版本方法，它们会返回基于 UTC+0 时区的天数、月份、年份等等信息：[getUTCFullYear()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCFullYear)， [getUTCMonth()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMonth)， [getUTCDay()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCDay)。只需要在 `"get"` 之后插入 `"UTC"`。

如果你当地时区相对于 UTC 有偏移，那么下面代码会显示不同的小时数：

```javascript
//  当前日期
let date = new Date();

// 当地时区的小时数
alert( date.getHours() );

// 在 UTC+0 时区的小时数（非夏令时的伦敦时间）
alert( date.getUTCHours() );
```

在以上给出的方法中，有两个与众不同的，它们没有 UTC 版本：

- [getTime()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime)

  返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始的毫秒数。

- [getTimezoneOffset()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)

  返回时区偏移数，以分钟为单位：`// 如果你在时区 UTC-1，输出 60 // 如果你在时区 UTC+3，输出 -180 alert( new Date().getTimezoneOffset() );`

##### [设置日期信息](https://zh.javascript.info/date#she-zhi-ri-qi-xin-xi)

以下方法可以设置日期/时间信息：

- [`setFullYear(year [ ,month, date])`](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear)
- [`setMonth(month [, date])`](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth)
- [`setDate(date)`](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate)
- [`setHours(hour [, min, sec, ms])`](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours)
- [`setMinutes(min [,sec, ms])`](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMinutes)
- [`setSeconds(sec [, ms])`](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setSeconds)
- [`setMilliseconds(ms)`](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMilliseconds)
- [`setTime(milliseconds)`](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime) （使用自 1970-01-01 00:00:00 UTC+0 开始的毫秒数来设置整个日期对象）

以上方法除了 `setTime()` 都有 UTC 版本，比如 `setUTCHours()`。

我们可以看到，有些方法可以一次性设置多个信息，比如 `setHours`。另外，在这些方法中没有提到的信息将不会被修改。

举个例子：

```javascript
let today = new Date();

today.setHours(0);
alert(today); // 日期依然是今天，只不过小时数改为 0

today.setHours(0, 0, 0, 0);
alert(today); // 日期依然是今天，时间为 00:00:00。
```

##### [自动校准](https://zh.javascript.info/date#zi-dong-xiao-zhun)

**自动校准**是 `Date` 对象一个非常方便的特性。我们可以设置超范围的数值，它会自动校准。

举个例子：

```javascript
let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...是 1st Feb 2013!
```

超出范围的日期信息会被自动分配。

假设我们要在日期「2016 年 2 月 28 日」上再加 2 天。结果可能是「3 月 2 日」或者「3 月 1 日」，原因是闰年的存在。但是我们不需要去考虑这些，直接加两天，剩下的 `Date` 对象会帮我们处理：

```javascript
let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 2016 年 3 月 1 日
```

这个特性经常被用来获取一段时间后的日期信息。举个例子，我们想得到「当前日期 70 秒之后的日期」：

```javascript
let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // 显示正确的日期信息
```

我们可以设置 0 甚至 负值。举个例子：

```javascript
let date = new Date(2016, 0, 2); // 2016 年 1 月 2 日

date.setDate(1); // 设置为当月的第一天
alert( date );

date.setDate(0); // 天数最小可以设置为 1，所以这里设置为上一月的最后一天
alert( date ); // 2015 年 12 月 31 日
```

##### [日期转化为数字，日期差值](https://zh.javascript.info/date#ri-qi-zhuan-hua-wei-shu-zi-ri-qi-cha-zhi)

当 `Date` 对象转化为数字时，得到的是对应的时间戳，相当于 `date.getTime()`：

```javascript
let date = new Date();
alert(+date); // 以毫秒为单位的数值，相当于 date.getTime()
```

有一个重要的副作用：日期可以相减，它们相减的结果是以毫秒为单位。

这个作用可以用来做时间度量：

```javascript
let start = new Date(); // 起始时间

// 做一些操作
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // 结束时间

alert( `The loop took ${end - start} ms` );
```

##### [Date.now()](https://zh.javascript.info/date#datenow)

如果我们仅仅想要度量时间间隔，我们不需要整个 `Date` 对象。

有一个特殊的方法 `Date.now()`，它会返回当前的时间戳。

它相当于 `new Date().getTime()`，但它不会在中间创建一个 `Date` 对象。因此它更快，而且不会对垃圾处理造成额外的压力。

这种方法很多时候因为方便而被采用，又或者从性能上考虑，像 JavaScript 中的游戏以及其他的特殊应用。

因此这样做可能会更好：

```javascript
let start = Date.now(); // 从 1979-01-01 00:00:00 开始至今的时间戳

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // 操作完成后，得到这一时刻的时间戳

alert( `The loop took ${end - start} ms` ); // 相减的是时间戳，而不是日期
```

##### [基准](https://zh.javascript.info/date#ji-zhun)

如果我们想要为一个很耗 CPU 性能的函数提供一个可靠的基准，我们应该小心一点。

举个例子：我们想判断两个计算日期差值的函数，那个更快？

```javascript
// 我们有 date1 和 date2，哪个函数会更快返回两者的时间差？
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// or
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
```

两个函数做的事情完全相同，但是其中一个明确使用 `date.getTime()` 来获取毫秒形式的日期，另外一个依赖「日期-数字」的转化。它们的结果是一致的。

那么，哪个更快呢？

首先想到的方法是：分别运行它们很多次，然后计算各自的时间差。在我们的例子中，函数非常简单，所以我们需要运行 100000 次左右。

让我们开始测量：

```javascript
function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );
alert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );
```

哇！使用 `getTime()` 这种方式快得多！原因是它没有类型转化，这样对引擎优化来说更加简单。

好，我们得到了结论，但是这并不是一个很好的基准例子。

想象一下当运行 `bench(diffSubtract)` 的同时，CPU 还在并行处理其他事务。然而，运行 `bench(diffGetTime)` 的时候，并行处理的事务完成了。

这是一个对于现代多进程操作系统来说，毫不夸张的场景。

结果就是，第一个函数相比于第二个，缺少 CPU 资源，这可能导致错误的结论。

**为了得到更加可靠的基准，所有的时间间隔需要多次返回。**

下面是示范代码：

```javascript
function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// 交替运行 bench(upperSlice) 和 bench(upperLoop) 10 次
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Total time for diffSubtract: ' + time1 );
alert( 'Total time for diffGetTime: ' + time2 );
```

现代的 JavaScript 引擎的先进优化策略只对执行很多次的 “hot code” 有效（对于执行很少次数的代码没有必要优化）。因此，以上的例子中，第一部分不会被优化，我们可能需要增加一个升温步骤：

```javascript
// 主循环中增加「升温」环节
bench(diffSubtract);
bench(diffGetTime);

// 开始度量
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
```

------

**做微度量时请小心**

现代的 JavaScript 引擎会做很多优化。相对于「正常情况」，它们可能会改变「人为测试」的结果，特别是我们度量的目标很细微。因此，如果你想好好了解一下性能，请学习 JavaScript 引擎的工作原理。在那之后，你可能再也不需要微度量了。

关于 V8 引擎的大量文章，点击：[http://mrale.ph](http://mrale.ph/).

##### [对一个字符串使用 Date.parse](https://zh.javascript.info/date#dui-yi-ge-zi-fu-chuan-shi-yong-dateparse)

[Date.parse(str)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/parse) 方法可以从一个字符串中读取日期。

字符串的格式是：`YYYY-MM-DDTHH:mm:ss.sssZ`，其中：

- `YYYY-MM-DD` —— 日期：年-月-日。
- 字符串 `"T"` 是一个分隔符。
- `HH:mm:ss.sss` —— 时间：小时，分钟，秒，毫秒。
- 可选字符 `'Z'` 代表时区。单个字符 `Z` 代表 UTC+0。

简短形式也是可以的，比如 `YYYY-MM-DD` 或者 `YYYY-MM` 又或者 `YYYY`。

`Date.parse(str)` 方法会转化一个特定格式的字符串，返回一个时间戳（自 1970-01-01 00:00:00 起的毫秒数），如果格式不正确，返回 `NaN`。

举个例子：

```javascript
let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417  (时间戳)
```

我们可以通过时间戳来立即创建一个 `new Date` 对象戳：

```javascript
let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);
```

##### [小结](https://zh.javascript.info/date#xiao-jie)

- 在 JavaScript 中，日期和时间使用 [Date](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date) 对象来表示。不能只创建日期，或者只创建时间，`Date` 对象总是两个都创建。
- 月份从 0 开始计数（对，一月是 0）。
- 一周的某一天 `getDay()` 同样从 0 开始计算（0 代表星期天）。
- 当超出范围的信息被设置时，`Date` 会做自我校准。这一点对于日/月/小时 的加减很有效。
- 日期可以相减，得到的是两者的差值，用毫秒表示。因为当转化为数字时，`Date` 对象变为时间戳。
- 使用 `Date.now()` 可以更快地得到当前时间的时间戳。

和其他语言不同，JavaScript 中时间戳是用毫秒表示，而不是秒。

同样，有时候我们会需要更加精准的时间度量。JavaScript 自身并不能度量微秒（一秒的百万分之一），但很多环境会提供。举个例子：浏览器拥有 [performance.now()](https://developer.mozilla.org/zh/docs/Web/API/Performance/now) 方法来提供页面加载的微秒数（毫秒的小数点再右移三位）：

```javascript
alert(`Loading started ${performance.now()}ms ago`);
// 得到 "Loading started 34731.26000000001ms ago"
// .26 is 微秒(260 微秒)
// 小数点后超过 3 位是错误，只有前三位是正确的
```

Node.JS 拥有 `microtime` 模块以及其他方法。从技术上来说，任何设备和环境都允许获取更精确的数值，不只是 `Date` 对象。

